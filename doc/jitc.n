.\"t
.\" Automatically generated by Pandoc 2.9.2.1
.\"
.TH "jitc" "3" "0.2" "0.2" "Just In Time C for Tcl"
.hy
.SH JITC
.PP
Just In Time C for Tcl
.SS SYNOPSIS
.PP
\f[B]package require jitc\f[R] ?0.2?
.PP
\f[B]jitc::capply\f[R] \f[I]cdef\f[R] \f[I]symbol\f[R] ?\f[I]arg\f[R]
\&...?
.PD 0
.P
.PD
\f[B]jitc::symbols\f[R] \f[I]cdef\f[R]
.PD 0
.P
.PD
\f[B]jitc::packageinclude\f[R]
.PD 0
.P
.PD
\f[B]jitc::re2c\f[R] ?\f[I]option\f[R] \&...?
\f[I]source\f[R]
.PD 0
.P
.PD
\f[B]jitc::packcc\f[R] ?\f[I]option\f[R] \&...?
\f[I]source\f[R]
.PD 0
.P
.PD
\f[B]jitc::lemon\f[R] ?\f[I]option\f[R] \&...?
\f[I]source\f[R]
.SS DESCRIPTION
.PP
This package provides just-in-time compilation of C code to memory for
Tcl scripts, with the ability to call functions in that compiled object,
and reference-counted memory management for the compiled objects.
.PP
There are several other similar projects (critcl, tcc4tcl, etc.), but
this package takes a different design approach: treating C code and
related settings as a value stored in a Tcl_Obj and doing the
compilation as needed, caching the result and freeing the memory when
the last reference goes away.
.PP
The generation of object code is done by an embedded TinyCC compiler.
.PP
The compiler supports the most of the C99 and C11 C language standards.
.SS COMMANDS
.TP
\f[B]jitc::capply\f[R] \f[I]cdef\f[R] \f[I]symbol\f[R] ?\f[I]arg\f[R] \&...?
Execute \f[I]symbol\f[R] in the compiled \f[I]cdef\f[R] as a
Tcl_ObjCmdProc.
If \f[I]symbol\f[R] points to something other than a Tcl_ObjCmdProc
things are likely to get interesting quickly.
.TP
\f[B]jitc::symbols\f[R] \f[I]cdef\f[R]
Return a list of the symbols in \f[I]cdef\f[R].
.TP
\f[B]jitc::packageinclude\f[R]
Return the path for the headers bundled with this package.
.TP
\f[B]jitc::re2c\f[R] ?\f[I]option\f[R] \&...? \f[I]source\f[R]
Process the C source code \f[I]source\f[R] through the bundled
\f[B]re2c\f[R].
\f[I]option\f[R]s are as understood by \f[B]re2c\f[R] (see
\f[B]re2c\f[R](1)).
The modified source code is returned.
Useful as a filter (see the \f[B]filter\f[R] part) to implement very
fast regular expression based lexers.
.SS CDEF FORMAT
.PP
The \f[I]cdef\f[R] argument to \f[B]jitc::capply\f[R] and
\f[B]jitc:symbols\f[R] is a list of pairs of elements: \f[I]part\f[R]
and \f[I]value\f[R].
When compiling and linking the code the parts are applied in sequence.
\f[I]part\f[R] must be one of:
.TP
\f[B]code\f[R]
\f[I]value\f[R] is a chunk of C code as a string.
.TP
\f[B]file\f[R]
\f[I]value\f[R] names a file containing C code.
Cannot currently refer to a path handled by a Tcl VFS plugin.
.TP
\f[B]mode\f[R]
Select the mode of operation \f[I]value\f[R], which must be either
\f[B]tcl\f[R] (the default), or \f[B]raw\f[R].
\f[B]tcl\f[R] mode automatically sets up include and library search
paths to link to the running Tcl interpreter, and includes a header file
which brings in \f[B]tcl.h\f[R] and defines a handful of convenience
macros for implementing Tcl commands in C (see the \f[B]CONVENIENCE
MACROS\f[R] section).
Mode \f[B]raw\f[R] turns off this behaviour.
.TP
\f[B]debug\f[R]
\f[I]value\f[R] names a filesystem path (which must exist, and be a
directory) into which to write copies of the code sections specified by
\f[B]code\f[R] parts.
This is useful when debugging the code, so that the debugger can find
the source code.
The files are removed when the \f[I]cdef\f[R] is freed (except if the
program crashes, in which case having the files left behind is
beneficial for examining the resulting core file in a debugger).
.TP
\f[B]options\f[R]
\f[I]value\f[R] contains an option string as would be passed to
\f[B]tcc(1)\f[R].
For example, to turn on debugging and all warnings, and bounds checking:
\f[B]-g -Wall -b\f[R].
.TP
\f[B]include_path\f[R]
Add the path in \f[I]value\f[R] to the paths searched for include files.
.TP
\f[B]sysinclude_path\f[R]
Add the path in \f[I]value\f[R] to the paths searched for system include
files.
.TP
\f[B]symbols\f[R]
Import symbols from the \f[I]cdef\f[R] given as the first element of
\f[I]value\f[R].
The following (0 or more) elements of \f[I]value\f[R] name symbols to
import from that cdef.
.TP
\f[B]library_path\f[R]
Add the path in \f[I]value\f[R] to the list of paths searched for
libraries.
.TP
\f[B]library\f[R]
Add the path in \f[I]value\f[R] to the libraries linked into the code.
.TP
\f[B]tccdir\f[R]
Set the default path searched for the built-in tcc libraries and
headers.
Defaults to the bundled files with this package.
.TP
\f[B]define\f[R]
Define a preprocessor symbol.
\f[I]value\f[R] must be a 2 element list, the first of which is the name
of the symbol and the second its value.
.TP
\f[B]undefine\f[R]
Undefine the preprocessor symbol \f[I]value\f[R].
.TP
\f[B]package\f[R]
Load and link with the Tcl package \f[I]value\f[R], which must be a
list, the first element of which names the required package and the
remaining elements are args as accepted by the \f[B]package require\f[R]
Tcl command to constrain the version requirements.
In addition to loading the package, if it exports build information via
\f[I]package_name\f[R]\f[B]::pkgconfig\f[R] (Tip #59,
Tcl_RegisterConfig) the exported configuration will be used to
automatically extend the include and library paths searched, link in the
library and automatically include the package\[cq]s header file in all
\f[B]code\f[R] parts.
The values used from the exported config are:
.RS
.PP
.TS
tab(@);
l l.
T{
Key
T}@T{
Effect
T}
_
T{
header
T}@T{
Added as an include in all \f[B]code\f[R] parts
T}
T{
includedir,runtime
T}@T{
Added as a search path for headers, ala -I
T}
T{
includedir,install
T}@T{
Added as a search path for headers, ala -I
T}
T{
libdir,runtime
T}@T{
Added as a search path for libraries, ala -L
T}
T{
libdir,install
T}@T{
Added as a search path for libraries, ala -L
T}
T{
library
T}@T{
Linked into the compiled code, ala -l
T}
.TE
.PP
Any keys that aren\[cq]t defined are ignored.
.RE
.TP
\f[B]filter\f[R]
Pass the C source code through the filter specified by \f[I]value\f[R],
which must be a Tcl command prefix to which will be added an arg
containing the C source code and which must return the modified source.
.TP
\f[B]export\f[R]
Declare the symbols exported from this object and the header text
required to use them, for use by other cdefs as described by the
\f[B]use\f[R] part below.
\f[I]value\f[R] must be a dictionary with keys described below:
.RS
.PP
.TS
tab(@);
l l.
T{
Key
T}@T{
Description
T}
_
T{
\f[B]symbols\f[R]
T}@T{
A list of the exported symbols.
Optional
T}
T{
\f[B]header\f[R]
T}@T{
The text of the header section to include.
Optional
T}
.TE
.RE
.TP
\f[B]use\f[R]
Link with the cdef given in \f[I]value\f[R].
Any symbols and header text it declares in its \f[B]export\f[R] part are
automatically imported.
.SS SPECIAL SYMBOLS
.PP
If the \f[I]cdef\f[R] exports a symbol \f[B]init\f[R] then that is
called when the compile is done.
\f[B]init\f[R] must be a function taking a \f[B]Tcl_Interp\f[R] and
returning \f[B]int\f[R]: TCL_OK if the initialization succeeded or
TCL_ERROR if it failed (an error message should be left in the
interpreter result as usual in this case).
Any error thrown will propagate to the command that caused the
compilation.
.PP
If the \f[I]cdef\f[R] exports a symbol \f[B]release\f[R] then it is
called when the memory containing the compiled \f[I]cdef\f[R] is about
to be freed.
It must be a function taking \f[B]Tcl_Interp\f[R] and returning
\f[B]void\f[R].
It should reverse any side effects created in the interpreter by
\f[B]init\f[R] or any of the code run in the \f[I]cdef\f[R], and free
any memory it allocated.
.SS CONVENIENCE MACROS
.PP
In the default \f[B]tcl\f[R] mode (as selected by the \f[B]mode\f[R]
part of the \f[I]cdef\f[R]), some helpful macros and utilities are
included:
.PP
.TS
tab(@);
lw(35.0n) lw(35.0n).
T{
Macro
T}@T{
Description
T}
_
T{
\f[B]INIT\f[R]
T}@T{
Expands to the standard initialization hook export: \[lq]int
init(Tcl_Interp* interp)\[rq].
T}
T{
\f[B]RELEASE\f[R]
T}@T{
Expands to the standard release hook export: \[lq]void
release(Tcl_Interp* interp)\[rq].
T}
T{
\f[B]OBJCMD\f[R](\f[I]name\f[R])
T}@T{
Defines a Tcl_ObjCmdProc named \f[I]name\f[R].
\f[B]cdata\f[R] is the passed ClientData, \f[B]interp\f[R] is the
Tcl_Interp, \f[B]objc\f[R] holds the count of arguments and
\f[B]objv\f[R] is an array of Tcl_Obj pointers to the arguments.
T}
T{
\f[B]CHECK_ARGS\f[R](\f[I]expecting\f[R], \f[I]msg\f[R])
T}@T{
Checks that the count of arguments passed to the command matches
\f[I]expecting\f[R] (in addition to the command argument itself).
If not, an error message is left in the \f[B]interp\f[R] containing
\f[I]msg\f[R] and we return \f[B]TCL_ERROR\f[R].
T}
T{
\f[B]TEST_OK_LABEL\f[R](\f[I]label\f[R], \f[I]code\f[R],
\f[I]checked_command\f[R])
T}@T{
Test the return code from \f[I]checked_command\f[R] and store it in
\f[I]code\f[R].
If it differs from \f[B]TCL_OK\f[R] jump to the label \f[I]label\f[R].
Useful to implement exception handling that releases any allocated
resources and returns \f[I]code\f[R] at the end of the function.
T}
T{
\f[B]replace_tclobj\f[R](\f[I]varPtr\f[R], \f[I]replacement\f[R])
T}@T{
Assign the Tcl_Obj pointed to by \f[I]replacement\f[R] into the variable
whose address is \f[I]varPtr\f[R], managing the refCount for the
Tcl_Objs.
If the variable being assigned to already pointed to a Tcl_Obj, its
refcount is decremented.
If \f[I]replacement\f[R] is non-NULL its refcount is incremented.
T}
.TE
.PP
To make these available in source code referend in \f[B]file\f[R] parts,
or \f[B]code\f[R] parts in \f[B]raw\f[R] \f[B]mode\f[R], include
\f[B]tclstuff.h\f[R], which is installed in the package installation
directory.
This is in the default include search path for \f[B]mode\f[R]
\f[B]tcl\f[R], but can be retrieved by the command
\f[B]jitc::packageinclude\f[R]
.SS EXAMPLES
.PP
Hello, world:
.IP
.nf
\f[C]
package require jitc

jitc::capply {
    code {
        int hello(ClientData cdata, Tcl_Interp* interp, int objc, Tcl_Obj *const objv[])
        {
            if (objc != 2) {
                Tcl_WrongNumArgs(interp, 1, objv, \[dq]noun\[dq]);
                return TCL_ERROR;
            }
            Tcl_SetObjResult(interp, Tcl_ObjPrintf(\[dq]hello, %s\[dq], Tcl_GetString(objv[1])));
            return TCL_OK;
        }
    }
} hello jitc
\f[R]
.fi
.SS Resource Management
.PP
\f[B]init\f[R] and \f[B]release\f[R] symbols for resource management:
.IP
.nf
\f[C]
package require jitc

set cdef [string trim { code {
    #include <stdio.h>

    Tcl_DString     g_str;

    int accumulate(ClientData cdata, Tcl_Interp* interp, int objc, Tcl_Obj *const objv[])
    {
        int len;
        const char* str;

        if (objc != 2) {
            Tcl_WrongNumArgs(interp, 1, objv, \[dq]string\[dq]);
            return TCL_ERROR;
        }

        str = Tcl_GetStringFromObj(objv[1], &len);

        Tcl_DStringAppend(&g_str, str, len);

        printf(\[dq]Current value of the accumulated value: %*s\[rs]n\[dq],
            Tcl_DStringLength(&g_str),
            Tcl_DStringValue(&g_str));

        return TCL_OK;
    }

    int init(Tcl_Interp* interp)
    {
        Tcl_DStringInit(&g_str);
        printf(\[dq]%s\[dq], \[dq]Initialized g_str\[rs]n\[dq]);
    }

    void release(Tcl_Interp* interp)
    {
        Tcl_DStringFree(&g_str);
        printf(\[dq]%s\[dq], \[dq]Freed g_str\[rs]n\[dq]);
    }
}}]     ;# string trim to avoid a reference in the literal table

jitc::capply $cdef accumulate \[dq]foo\[dq]
jitc::capply $cdef accumulate \[dq]bar\[dq]

unset cdef
\f[R]
.fi
.PP
Produces:
.IP
.nf
\f[C]
Initialized g_str
Current value of the accumulated value: foo
Current value of the accumulated value: foobar
Freed g_str
\f[R]
.fi
.SS Filters
.PP
Check if the supplied argument is a valid decimal number, using a re2c
filter and the standard convenience macros:
.IP
.nf
\f[C]
package require jitc

jitc::capply {
    filter  {jitc::re2c --no-debug-info --case-ranges}
    code    {
        static Tcl_Obj* g_true  = NULL;
        static Tcl_Obj* g_false = NULL;

        INIT {
            replace_tclobj(&g_true,  Tcl_NewBooleanObj(1));
            replace_tclobj(&g_false, Tcl_NewBooleanObj(0));
            return TCL_OK;
        }

        RELEASE {
            replace_tclobj(&g_true,  NULL);
            replace_tclobj(&g_false, NULL);
        }

        OBJCMD(isdecimal) {
            CHECK_ARGS(1, \[dq]str\[dq]);
            int         len;
            const char* str = Tcl_GetStringFromObj(objv[1], &len);
            const char* YYCURSOR = str;
            const char* YYLIMIT  = str+len;
            const char* YYMARKER;
            /*!re2c
                re2c:yyfill:enable = 0;
                re2c:define:YYCTYPE = \[dq]char\[dq];
                re2c:eof = 0;

                number = [1-9][0-9]*;

                number  {
                    Tcl_SetObjResult(interp,
                        YYCURSOR==YYLIMIT ? g_true : g_false
                    );
                    goto done;
                }
                $       { Tcl_SetObjResult(interp, g_false); goto done; }
                *       { Tcl_SetObjResult(interp, g_false); goto done; }
            */
        done:
            return TCL_OK;
        }
    }
} isdecimal 12345
\f[R]
.fi
.PP
Note the use of global Tcl_Objs \f[B]g_true\f[R] and \f[B]g_false\f[R]
to store cached true and false Tcl values.
This is safe to do here because this compiled object can only be called
from this Tcl interpreter (and thus thread), and the created objects are
released in the RELEASE handler, so that when the \f[I]cdef\f[R] value
is no longer reachable they will be freed, avoiding a memory leak.
Also, although they are global variables, they are not exported by the
linker, so their scope is limited to only the code in this
\f[B]code\f[R] part.
.SS Package Dependencies
.PP
Use the \f[B]package\f[R] part mechanism to bring in the \f[B]dedup\f[R]
package (https://github.com:cyanogilvie/dedup) and automatically load
it, include its header, link to the lib and set up the include and
library search paths for the compiler to find its resources.
This automatic setup requires the package to make its build information
available via the Tcl_RegisterConfig (TIP 59) mechanism, as described in
the \f[B]package\f[R] part:
.IP
.nf
\f[C]
package require jitc

set cdef {
    package     {dedup 0.9.3}
    code        {
        struct dedup_pool* g_dedup = NULL;

        INIT {
            g_dedup = Dedup_NewPool(interp);
            return TCL_OK;
        }

        RELEASE {
            Dedup_FreePool(g_dedup);
            g_dedup = NULL;
        }

        OBJCMD(dedup) {
            CHECK_ARGS(1, \[dq]string\[dq]);
            int len;
            const char* str = Tcl_GetStringFromObj(objv[1], &len);
            Tcl_SetObjResult(interp, Dedup_NewStringObj(g_dedup, str, len));
            return TCL_OK;
        }

        OBJCMD(stats) {
            Tcl_DString ds;

            CHECK_ARGS(0, \[dq]\[dq]);
            Tcl_DStringInit(&ds);
            Dedup_Stats(&ds, g_dedup);
            Tcl_SetObjResult(interp,
                Tcl_NewStringObj(Tcl_DStringValue(&ds),
                Tcl_DStringLength(&ds)));
            Tcl_DStringFree(&ds);
            return TCL_OK;
        }
    }
}

set first   [jitc::capply $cdef dedup \[dq]foo bar\[dq]]
set second  [jitc::capply $cdef dedup \[dq]foo bar\[dq]]
puts \[dq]first:  [tcl::unsupported::representation $first]\[dq]
puts \[dq]second: [tcl::unsupported::representation $first]\[dq]
puts \[dq]dedup pool stats:\[rs]n[jitc::capply $cdef stats]\[dq]
\f[R]
.fi
.SS C API
.PP
This package exports a stubs API for use by other extensions:
.TP
int \f[B]Jitc_GetSymbolFromObj\f[R](Tcl_Interp* \f[I]interp\f[R], Tcl_Obj* \f[I]cdef\f[R], Tcl_Obj* \f[I]symbol\f[R], void** \f[I]val\f[R])
Retrieve the symbol \f[I]symbol\f[R] from \f[I]cdef\f[R], compiling it
if needed.
.TP
int \f[B]Jitc_GetSymbolsFromObj\f[R](Tcl_Interp* \f[I]interp\f[R], Tcl_Obj* \f[I]cdef\f[R], Tcl_Obj** \f[I]symbols\f[R])
Retrieve a list of all symbols in \f[I]cdef\f[R], compiling it if
needed.
.TP
int \f[B]Jitc_GetExportHeadersFromObj\f[R](Tcl_Interp* \f[I]interp\f[R], Tcl_Obj* \f[I]cdef\f[R], Tcl_Obj** \f[I]headers\f[R])
Retrieve the headers text exported from \f[I]cdef\f[R], compiling it if
needed.
\f[I]headers\f[R] may be NULL if \f[I]cdef\f[R] doesn\[cq]t declare any
exported header.
Will still return \f[B]TCL_OK\f[R] for this case.
.TP
int \f[B]Jitc_GetExportSymbolsFromObj\f[R](Tcl_Interp* \f[I]interp\f[R], Tcl_Obj* \f[I]cdef\f[R], Tcl_Obj** \f[I]symbols\f[R])
Retrieve a list of the symbols declared for export from \f[I]cdef\f[R],
compiling it if needed.
\f[I]symbols\f[R] may be NULL if \f[I]cdef\f[R] doesn\[cq]t declare any
exported symbols.
Will still return \f[B]TCL_OK\f[R] for this case.
.SS BUGS
.PP
Please report any bugs to the github issue tracker:
https://github.com/cyanogilvie/jitc/issues
.SS SEE ALSO
.PP
critcl: https://wiki.tcl-lang.org/page/Critcl, tcc4tcl:
https://wiki.tcl-lang.org/page/tcc4tcl, tcc(1),
https://repo.or.cz/tinycc.git, re2c: https://en.wikipedia.org/wiki/Re2c,
packcc: https://en.wikipedia.org/wiki/PackCC, lemon:
https://sqlite.org/src/doc/trunk/doc/lemon.html.
.SS PROJECT STATUS
.PP
Work in progress, only very basic testing has been done.
Using it anywhere that matters would be very brave indeed.
.SS TODO
.IP \[bu] 2
\[u2612] Implement \f[B]init\f[R] and \f[B]release\f[R]
.IP \[bu] 2
\[u2612] Implement \f[B]packageinclude\f[R]
.IP \[bu] 2
\[u2612] Implement \f[B]filter\f[R]
.IP \[bu] 2
\[u2612] Implement \f[B]jitc::re2c\f[R] wrapper
.IP \[bu] 2
\[u2610] Implement \f[B]jitc::packcc\f[R] wrapper
.IP \[bu] 2
\[u2610] Implement \f[B]jitc::lemon\f[R] wrapper
.IP \[bu] 2
\[u2610] Proper exceptions on compile errors
.IP \[bu] 2
\[u2610] More test coverage
.IP \[bu] 2
\[u2610] Document coverage, debugging
.SS LICENSE
.PP
This package is Copyright 2022 Cyan Ogilvie, and is made available under
the same license terms as the Tcl Core.
The TCC compiler is LGPL.
This package does not distribute object code or source code from TCC and
so doesn\[cq]t trigger any GPL issues, but if you build this package and
distribute the result you will need to ensure that you are in compliance
with the terms of the TCC LGPL license.
The git submodules for the linked tools each have their own license:
TinyCC is LGPL; re2c is public domain; packcc is MIT; lemon and sqlite
are public domain.
.SH AUTHORS
Cyan Ogilvie.
