.\" Automatically generated by Pandoc 2.9.2.1
.\"
.TH "tinycc" "3" "0.1" "0.1" "Just In Time C for Tcl"
.hy
.SH NAME
.PP
tinycc - Just In Time C for Tcl
.SH SYNOPSIS
.PP
\f[B]package require tinycc\f[R] ?0.1?
.PP
\f[B]tinycc::capply\f[R] \f[I]cdef\f[R] \f[I]symbol\f[R] ?\f[I]arg\f[R]
\&...?
.PD 0
.P
.PD
\f[B]tinycc::symbols\f[R] \f[I]cdef\f[R]
.SH DESCRIPTION
.PP
This package provides just-in-time compilation of c code to memory for
Tcl scripts, with the ability to call functions in that compiled object,
and reference-counted memory management for the compiled objects.
.PP
There are several other similar projects (critcl, tcc4tcl, etc.), but
this package takes a different design approach: treating c code and
related settings as a value stored in a Tcl_Obj and doing the
compilation as needed, caching the result and freeing the memory when
the last reference goes away.
.PP
The generation of object code is done by an embedded TinyCC compiler.
.SH COMMANDS
.TP
\f[B]tinycc::capply\f[R] \f[I]cdef\f[R] \f[I]symbol\f[R] ?\f[I]arg\f[R] \&...?
Execute \f[I]symbol\f[R] in the compiled \f[I]cdef\f[R] as a
Tcl_ObjCmdProc.
If \f[I]symbol\f[R] points to something other than a Tcl_ObjCmdProc
things are likely to get interesting quickly.
.TP
\f[B]tinycc::symbols\f[R] \f[I]cdef\f[R]
Return a list of the symbols in \f[I]cdef\f[R].
.SH CDEF FORMAT
.PP
The \f[I]cdef\f[R] argument to \f[B]tinycc::capply\f[R] and
\f[B]tinycc:symbols\f[R] is a list of pairs of elements: \f[I]part\f[R]
and \f[I]value\f[R].
When compiling and linking the code the parts are applied in sequence.
\f[I]part\f[R] must be one of:
.TP
\f[B]code\f[R]
\f[I]value\f[R] is a chunk of c code as a string.
.TP
\f[B]file\f[R]
\f[I]value\f[R] names a file containing c code.
Cannot currently refer to a path handled by a Tcl VFS plugin.
.TP
\f[B]debug\f[R]
\f[I]value\f[R] names a filesystem path (which must exist, and be a
directory) in which to write copies of the code sections specified by
\f[B]code\f[R] parts.
This is useful when debugging the code, so that the debugger can find
the source code.
The files are removed when the \f[I]cdef\f[R] is freed (except if the
program crashes, in which case having the files left behind is
beneficial for examining the resulting core file in a debugger).
.TP
\f[B]options\f[R]
\f[I]value\f[R] contains an option string as would be passed to
\f[B]tcc(1)\f[R].
For example, to turn on debugging and all warnings, and bounds checking:
\f[B]-g -Wall -b\f[R].
.TP
\f[B]include_path\f[R]
Add the path in \f[I]value\f[R] to the paths searched for include files.
.TP
\f[B]sysinclude_path\f[R]
Add the path in \f[I]value\f[R] to the paths searched for system include
files.
.TP
\f[B]symbol\f[R]
Define a symbol: \f[I]value\f[R] is a two element list, the first of
which is another \f[I]cdef\f[R] and the second the name of the symbol
from that \f[I]cdef\f[R] to import.
.TP
\f[B]library_path\f[R]
Add the path in \f[I]value\f[R] to the list of paths searched for
libraries.
.TP
\f[B]library\f[R]
Add the path in \f[I]value\f[R] to the libraries linked into the code.
.TP
\f[B]tccdir\f[R]
Set the default path searched for the built-in tcc libraries and
headers.
Defaults to the bundled files with this package.
.TP
\f[B]define\f[R]
Define a preprocessor symbol.
\f[I]value\f[R] must be a 2 element list, the first of which is the name
of the symbol and the second its value.
.TP
\f[B]undefine\f[R]
Undefine the preprocessor symbol \f[I]value\f[R].
.SH SPECIAL SYMBOLS
.PP
If the \f[I]cdef\f[R] exports a symbol \f[B]init\f[R] then that is
called when the compile is done.
\f[B]init\f[R] must be a function taking a \f[B]Tcl_Interp\f[R] and
returning \f[B]int\f[R]: TCL_OK if the initialization succeeded or
TCL_ERROR if it failed (an error message should be left in the
interpreter result as usual in this case).
Any error thrown will propagate to the command that caused the
compilation.
.PP
If the \f[I]cdef\f[R] exports a symbol \f[B]release\f[R] then it is
called when the memory containing the compiled \f[I]cdef\f[R] is about
to be freed.
It must be a function taking \f[B]Tcl_Interp\f[R] and returning void.
It should reverse any side effects created in the interpreter by
\f[B]init\f[R] or any of the code run in the \f[I]cdef\f[R], and free
any memory it allocated.
.SH EXAMPLES
.PP
Hello, world:
.IP
.nf
\f[C]
package require tinycc

tinycc::capply {
    code {
        int hello(ClientData cdata, Tcl_Interp* interp, int objc, Tcl_Obj *const objv[])
        {
            if (objc != 2) {
                Tcl_WrongNumArgs(interp, 1, objv, \[dq]noun\[dq]);
                return TCL_ERROR;
            }
            Tcl_SetObjResult(interp, Tcl_ObjPrintf(\[dq]hello, %s\[dq], Tcl_GetString(objv[1])));
            return TCL_OK;
        }
    }
} hello tinycc
\f[R]
.fi
.PP
\f[B]init\f[R] and \f[B]release\f[R] symbols for resource management:
.IP
.nf
\f[C]
package require tinycc

set cdef [list code {
    #include <stdio.h>

    Tcl_DString     g_str;

    int accumulate(ClientData cdata, Tcl_Interp* interp, int objc, Tcl_Obj *const objv[])
    {
        int len;
        const char* str;

        if (objc != 2) {
            Tcl_WrongNumArgs(interp, 1, objv, \[dq]string\[dq]);
            return TCL_ERROR;
        }

        str = Tcl_GetStringFromObj(objv[1], &len);

        Tcl_DStringAppend(&g_str, str, len);

        printf(\[dq]Current value of the accumulated value: %*s\[rs]n\[dq],
            Tcl_DStringLength(&g_str),
            Tcl_DStringValue(&g_str));

        return TCL_OK;
    }

    int init(Tcl_Interp* interp)
    {
        Tcl_DStringInit(&g_str);
        printf(\[dq]%s\[dq], \[dq]Initialized g_str\[rs]n\[dq]);
    }

    void release(Tcl_Interp* interp)
    {
        Tcl_DStringFree(&g_str);
        printf(\[dq]%s\[dq], \[dq]Freed g_str\[rs]n\[dq]);
    }
}]

tinycc::capply $cdef accumulate \[dq]foo\[dq]
tinycc::capply $cdef accumulate \[dq]bar\[dq]

unset cdef
\f[R]
.fi
.PP
Produces:
.IP
.nf
\f[C]
Initialized g_str
Current value of the accumulated value: foo
Current value of the accumulated value: foobar
Freed g_str
\f[R]
.fi
.SH BUGS
.PP
Please report any bugs to the github issue tracker:
https://github.com/cyanogilvie/tinycc/issues
.SH SEE ALSO
.PP
tcc(1), https://repo.or.cz/tinycc.git
.SH PROJECT STATUS
.PP
Work in progress, only very basic testing has been done.
Using it anywhere that matters would be very brave indeed.
.SH TODO
.IP \[bu] 2
\[u2612] Implement \f[B]init\f[R] and \f[B]release\f[R]
.IP \[bu] 2
\[u2610] More test coverage
.IP \[bu] 2
\[u2610] Document coverage, debugging
.SH LICENSE
.PP
This package is Copyright 2022 Cyan Ogilvie, and is made available under
the same license terms as the Tcl Core.
The TCC compiler is LGPL.
This package does not distribute object code or source code from TCC and
so doesn\[cq]t trigger any GPL issues, but if you build this package and
distribute the result you will need to ensure that you are in compliance
with the terms of the TCC LGPL license.
.SH AUTHORS
Cyan Ogilvie.
