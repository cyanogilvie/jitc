proc readfile fn {
	set h	[open $fn]
	try {read $h} finally {close $h}
}

proc writefile {fn dat} {
	set h	[open $fn w]
	try {puts -nonewline $h $dat} finally {close $h}
}

puts "uid_map: [exec ls -l /proc/self/uid_map]"
#writefile /proc/self/uid_map "0 0 4294967295\n"
#writefile /proc/self/gid_map "0 0 4294967295\n"

puts "user: [exec id -u]"
#puts "processes: [exec ps -aux]"
puts "pid: [pid]"
puts "from ps: [exec ps -up [pid]]"
puts "uid_map: ([readfile /proc/self/uid_map])"
puts "gid_map: ([readfile /proc/self/gid_map])"
#puts "ls -l /tmp:\n[exec ls -l /tmp]"

package require jitc

puts "hello ($argv0), args: ($argv)"

if 0 {
set mountinfo	[lmap line [split [readfile /proc/self/mountinfo] \n] {
	if {![string match /tmp/memfs_* [lindex $line 4]]} continue
	set line
}]
puts "mountinfo: ($mountinfo)"
set mountpoint	[lindex $mountinfo 0 4]
lassign [split [lindex $mountinfo 0 2] :] major minor
set devnum		[expr {($major << 8) + $minor}]
puts "dev: $major:$minor, num: $devnum"

puts "glob: [timerate {puts "glob: [glob $mountpoint/*]"} 1 1], benchmark: [timerate {glob $mountpoint/*}]"
puts "readfile: [timerate {puts "readfile: ([readfile $mountpoint/foo])"} 1 1], benchmark: [timerate {readfile $mountpoint/foo}]"

# warmup
exec ls / $mountpoint

puts "ls: [timerate {
puts "ls $mountpoint:\n[exec ls -al $mountpoint]"
} 1 1]"
puts "cat [timerate {
puts "cat $mountpoint/foo: ([exec cat $mountpoint/foo])"
} 1 1]"
puts "ls /: [timerate {exec ls /} 1 1], benchmark: [timerate {exec ls /}]"
}

file delete -force -- /tmp/jitc_debugfiles
file mkdir /tmp/jitc_debugfiles
proc unshare args { #<<<
	jitc::capply {define _GNU_SOURCE debug /tmp/jitc_debugfiles options {-Wall -Werror -gdwarf-5} code {//@begin=c@
		#include <stdio.h>
		#include <sched.h>
		#include <linux/sched.h>

		OBJCMD(Unshare) {
			int			code = TCL_OK;

			static const char* flagstr[] = {
				"CLONE_FILES",
				"CLONE_FS",
				"CLONE_NEWCGROUP",
				"CLONE_NEWIPC",
				"CLONE_NEWNET",
				"CLONE_NEWNS",
				"CLONE_NEWPID",
				"CLONE_NEWTIME",
				"CLONE_NEWUSER",
				"CLONE_NEWUTS",
				"CLONE_SYSVSEM",
				"CLONE_THREAD",
				"CLONE_SIGHAND",
				"CLONE_VM",
				NULL
			};
			//@end=c@@begin=c@
			int flagmap[] = {
				CLONE_FILES,
				CLONE_FS,
				CLONE_NEWCGROUP,
				CLONE_NEWIPC,
				CLONE_NEWNET,
				CLONE_NEWNS,
				CLONE_NEWPID,
				CLONE_NEWTIME,
				CLONE_NEWUSER,
				CLONE_NEWUTS,
				CLONE_SYSVSEM,
				CLONE_THREAD,
				CLONE_SIGHAND,
				CLONE_VM
			};
			//@end=c@@begin=c@
			int flags = 0;

			for (int i=1; i<objc; i++) {
				int flagidx;

				TEST_OK_LABEL(done, code, Tcl_GetIndexFromObj(interp, objv[i], flagstr, "flag", TCL_EXACT, &flagidx));
				
				fprintf(stderr, "Adding flag: %s: 0x%x\n", flagstr[flagidx], flagmap[flagidx]);
				flags |= flagmap[flagidx];
			}
			//@end=c@@begin=c@

			fprintf(stderr, "Combined flags: 0x%x\n", flags);
			if (-1 == unshare(flags))
				THROW_POSIX_LABEL(done, code, "Error calling unshare");

		done:
			return code;
		}
	//@end=c@}} Unshare {*}$args
}

#>>>

jitc::capply [list code {//@begin=c@
#include <linux/fuse.h>
#include <stdio.h>
OBJCMD(t) {
	int			code = TCL_OK;
	CHECK_ARGS(0, "");
	fprintf(stderr, "Test command\n");
done:
	return code;
}
//@end=c@}] t

if 0 {
#unshare CLONE_NEWNS CLONE_NEWUSER
unshare CLONE_NEWNS
puts "Called unshare"
#writefile /proc/self/uid_map "0 0 4294967295\n"
#writefile /proc/self/gid_map "0 0 4294967295\n"
puts "Wrote uid_map and gid_map"
#unshare CLONE_NEWNS
}

package require Thread
set fs_tid	[thread::create -joinable -preserved {proc cleanup {} {}; thread::wait; cleanup}]
thread::send $fs_tid $::_threadinit
set tempdir	[thread::send $fs_tid {
	package require jitc
	package require parse_args
	namespace import ::parse_args::*

	proc cleanup {} { #<<<
		global fd tempdir

		puts stderr "In fs_tid cleanup"

		set mountpoint_busy	0
		try {
			puts stderr "Calling umount $tempdir"
			exec umount -f $tempdir
		} trap CHILDSTATUS {errmsg options} {
			lassign [dict get $options -errorcode] - pid rc
			if {$rc == 32} {
				set mountpoint_busy	1
			}
		} on error {errmsg options} {
			puts stderr "umount err: $options"
		}
		#puts stderr "Processing event queue after umount"
		#update

		if {[info exists fd] && $fd in [chan names]} {
			puts stderr "Closing fd"
			close $fd
			unset fd
		}

		if {!$mountpoint_busy && [info exists tempdir]} {
			puts stderr "Removing mountpoint dir $tempdir"
			file delete -force $tempdir
		}
		puts stderr "Leaving fs_tid cleanup"
	}

	#>>>

	set fd	[open /dev/fuse r+]
	chan configure $fd -blocking 1 -buffering none -translation binary

	proc readfile fn {
		set h	[open $fn r]
		try {read $h} finally {close $h}
	}

	set lookup_fd	{options {-Wall -Werror -gdwarf-5} code {//@begin=c@<<<
		#include <sys/mount.h>
		#include <stdio.h>

		OBJCMD(native) {
			int			code = TCL_OK;
			Tcl_Obj*	fsargs = NULL;
			ClientData	fd_cdata;
			Tcl_Channel	chan;

			CHECK_ARGS(1, "chan");

			int mode;
			chan = Tcl_GetChannel(interp, Tcl_GetString(objv[1]), &mode);
			if (chan == NULL) goto done;
			if (mode & TCL_READABLE == 0 || mode & TCL_WRITABLE == 0)
				THROW_ERROR_LABEL(done, code, "chan must be readable and writable");

			TEST_OK_LABEL(done, code, Tcl_GetChannelHandle(chan, TCL_READABLE, &fd_cdata));
			Tcl_SetObjResult(interp, Tcl_NewWideIntObj((Tcl_WideInt)fd_cdata));

		done:
			replace_tclobj(&fsargs, NULL);
			return code;
		}
	//@end=c@>>>}}

	# fuse_io <<<
	file delete -force /tmp/fuse_io; file mkdir /tmp/fuse_io
	set fuse_io	{debug /tmp/fuse_io options {-Wall -Werror -gdwarf-5} export {
			symbols	{fuse_write get_fd_from_obj}
			header	{
				int fuse_write(Tcl_Interp* interp, int fd, void* buf, size_t buflen);
				int get_fd_from_obj(Tcl_Interp* interp, Tcl_Obj* chan, int modereq, int* fd);
			}
		}
		code {//@begin=c@
			#include <linux/fuse.h>
			#include <unistd.h>
			#include <errno.h>

			int fuse_write(Tcl_Interp* interp, int fd, void* buf, size_t len) //<<<
			{
				int		code = TCL_OK;
				ssize_t	written = 0;

				do {
					const ssize_t wrote = write(fd, (void*)buf+written, len - written);
					if (wrote == -1) {
						if (errno = EINTR) continue;
						THROW_POSIX_LABEL(done, code, "Error calling write on fuse fd");
					}
					written += wrote;
					if (written < len) continue;
				} while(0);

			done:
				return code;
			}

			//>>>@end=c@@begin=c@
			int get_fd_from_obj(Tcl_Interp* interp, Tcl_Obj* chan, int modereq, int* fd) //<<<
			{
				int			code = TCL_OK;
				int			mode;
				ClientData	fd_cdata;

				Tcl_Channel channel = Tcl_GetChannel(interp, Tcl_GetString(chan), &mode);
				if (channel == NULL) goto done;
				if (mode & modereq == 0)
					THROW_ERROR_LABEL(done, code, "chan mode doesn't meet requirements");

				TEST_OK_LABEL(done, code, Tcl_GetChannelHandle(channel, modereq, &fd_cdata));
				*fd = (Tcl_WideInt)fd_cdata;

			done:
				return code;
			}

			//>>>
		//@end=c@}
	}
	# fuse_io >>>

	proc gen_flag_map args { #<<<
		parse_args $args {
			-headers	{-default {} -# {Headers to include that contain the required definitions}}
			-type		{-default int -# {The type of the mapped value}}
			-flags		{-required -# {A list of flags to generate mappings for}}
			-debug		{}
			-name		{-required -# {The map name}}
		}
		# TODO: validate that each element of $flags is a valid c identifier (syntactically)
		# TODO: validate that each element of $headers is a valid filename (syntactically)
		# TODO: validate that type and name are valid c symbols (syntactically)

		set code	{}

		set size	[llength $flags]

		set exported_symbols	{}
		set exported_headers	{}

		foreach header $headers {
			append exported_headers	"#include <$header>\n"
		}
		append code \n

		append code [subst {static const char* strs\[\] = {[join [lmap f $flags {
			format {"%s"} $f
		}] ,\n\t],\n\tNULL\n};}] \n
		append code [subst {static const $type map\[\] = {[join [lmap f $flags {
			format {%s} $f
		}] ,\n\t]\n};}] \n
		append code [subst {static Tcl_Obj* objs\[$size\] = {0};}] \n

		set i	-1
		append code "INIT \{\n\t[join [lmap f $flags {
			format {replace_tclobj(&objs[%d], Tcl_NewStringObj("%s", %d));} [incr i] $f [string length $f]
		}] \n\t]\n\treturn TCL_OK;\n\}\n\n"
		append code [subst {RELEASE {\n\tfor (int i=0; i<$size; i++) replace_tclobj(&objs\[i\], NULL);\n}}] \n\n

		append code [subst {int get_${name}_from_list(Tcl_Interp* interp, Tcl_Obj* list, $type* res)
{
	int code = TCL_OK;
	int idx;
	Tcl_Obj**	ov = NULL;
	int			oc;
	$type		acc = 0;
	TEST_OK_LABEL(done, code, Tcl_ListObjGetElements(interp, list, &oc, &ov));
	for (int i=0; i<oc; i++) {
		TEST_OK_LABEL(done, code, Tcl_GetIndexFromObj(interp, ov\[i\], strs, "$name", TCL_EXACT, &idx));
		acc |= map\[idx\];
	}
	*res = acc;

done:
	return code;
}}] \n\n
		lappend exported_symbols get_${name}_from_list
		append exported_headers "int get_${name}_from_list(Tcl_Interp* interp, Tcl_Obj* list, $type* res);\n"

		append code [subst {int get_list_from_${name}(Tcl_Interp* interp, $type flags, Tcl_Obj** list)
{
	int			code = TCL_OK;
	Tcl_Obj*	acc = NULL;

	replace_tclobj(&acc, Tcl_NewListObj(0, NULL));

	for (int i=0; i<$size; i++)
		if (flags & map\[i\] == map\[i\])
			TEST_OK_LABEL(done, code, Tcl_ListObjAppendElement(interp, acc, objs\[i\]));

	replace_tclobj(list, acc);
done:
	replace_tclobj(&acc, NULL);
	return code;
}}] \n\n
		lappend exported_symbols get_list_from_$name
		append exported_headers "int get_list_from_${name}(Tcl_Interp* interp, $type flags, Tcl_Obj** list);\n"

		if {[info exists debug]} {
			set debug	[list debug $debug]
		} else {
			set debug	{}
		}

		list {*}$debug options {-Wall -Werror -gdwarf-5} code $code export [list symbols $exported_symbols header $exported_headers]
	}

	#>>>
	proc gen_enum_map args { #<<<
		parse_args $args {
			-headers	{-default {} -# {Headers to include that contain the required definitions}}
			-type		{-default int -# {The type of the mapped value}}
			-vals		{-required -# {A list of enum values to generate mappings for}}
			-debug		{}
			-name		{-required -# {The map name}}
		}
		# TODO: validate that each element of $vals is a valid c identifier (syntactically)
		# TODO: validate that each element of $headers is a valid filename (syntactically)
		# TODO: validate that type and name are valid c symbols (syntactically)

		set code	{}

		set size	[llength $vals]

		set exported_symbols	{}
		set exported_headers	{}

		foreach header $headers {
			append exported_headers	"#include <$header>\n"
		}
		append code \n

		append code [subst {static const char* strs\[\] = {[join [lmap v $vals {
			format {"%s"} $v
		}] ,\n\t],\n\tNULL\n};}] \n
		append code [subst {static const $type map\[\] = {[join [lmap v $vals {
			format {%s} $v
		}] ,\n\t]\n};}] \n
		append code [subst {static Tcl_Obj* objs\[$size\] = {0};}] \n

		set i	-1
		append code "INIT \{\n\t[join [lmap v $vals {
			format {replace_tclobj(&objs[%d], Tcl_NewStringObj("%s", %d));} [incr i] $v [string length $v]
		}] \n\t]\n\treturn TCL_OK;\n\}\n\n"
		append code [subst {RELEASE {\n\tfor (int i=0; i<$size; i++) replace_tclobj(&objs\[i\], NULL);\n}}] \n\n

		append code [subst {int get_${name}_from_obj(Tcl_Interp* interp, Tcl_Obj* obj, $type* res)
{
	int code = TCL_OK;
	int idx;
	TEST_OK_LABEL(done, code, Tcl_GetIndexFromObj(interp, obj, strs, "$name", TCL_EXACT, &idx));
	*res = map\[idx\];

done:
	return code;
}}] \n\n
		lappend exported_symbols get_${name}_from_obj
		append exported_headers "int get_${name}_from_obj(Tcl_Interp* interp, Tcl_Obj* obj, $type* res);\n"

		append code [subst {int get_obj_from_${name}(Tcl_Interp* interp, $type val, Tcl_Obj** obj)
{
	int			code = TCL_OK;

	for (int i=0; i<$size; i++) {
		if (map\[i\] == val) {
			replace_tclobj(obj, objs\[i\]);
			goto done;
		}
	}

	// TODO: determine printf format for $type
	THROW_PRINTF_LABEL(done, code, "Unhandled $type value: %d\\n", val);

done:
	return code;
}}] \n\n
		lappend exported_symbols get_obj_from_$name
		append exported_headers "int get_obj_from_${name}(Tcl_Interp* interp, $type val, Tcl_Obj** obj);\n"

		if {[info exists debug]} {
			set debug	[list debug $debug]
		} else {
			set debug	{}
		}

		list {*}$debug options {-Wall -Werror -gdwarf-5} code $code export [list symbols $exported_symbols header $exported_headers]
	}

	#>>>
	proc gen_fuse_writer args { #<<<
		global fuse_io

		parse_args $args {
			-name		{-required}
			-debug		{}
			-fields		{-required}
		}

		set exported_symbols	{}
		set exported_headers	{}
		set code				{}
		set use_extra			{}

		append code [subst {
			[join [lmap {type field} $fields {subst {
				Tcl_Obj*	f_$field = NULL;
			}}] \n]

			INIT {
				[join [lmap {type field} $fields {subst {
					replace_tclobj(&f_$field, Tcl_NewStringObj("$field", [string length $field]));
				}}] \n]
				return TCL_OK;
			}

			RELEASE {
				[join [lmap {type field} $fields {subst {
					replace_tclobj(&f_$field, NULL);
				}}] \n]
			}

			OBJCMD(write_fuse_$name) {
				int				code = TCL_OK;
				int				fd;
				Tcl_WideInt		unique;
				Tcl_Obj*		k = NULL;
				Tcl_Obj*		v = NULL;
				int				done;
				const size_t	buflen = sizeof(struct fuse_out_header) + sizeof(struct fuse_${name}_out);
				uint8_t			buf\[buflen\];
				struct fuse_out_header*		hdr = (void*)buf;
				struct fuse_${name}_out*	reply = ((void*)buf)+sizeof(struct fuse_out_header);

				CHECK_ARGS(3, "fd unique msg");

				TEST_OK_LABEL(done, code, get_fd_from_obj(interp, objv\[1\], TCL_WRITABLE, &fd));
				TEST_OK_LABEL(done, code, Tcl_GetWideIntFromObj(interp, objv\[2\], &unique));

				*hdr = (struct fuse_out_header){
					.len	= buflen,
					.unique	= unique
				};
				*reply = (struct fuse_${name}_out){0};

				[join [lmap {type field} $fields {
					switch -glob -- $type {
						uint16_t -
						int32_t -
						uint32_t {subst {
							{
								int			l;
								Tcl_Obj*	v = NULL;
								TEST_OK_LABEL(done, code, Tcl_DictObjGet(interp, objv\[3\], f_$field, &v));
								if (v) {
									TEST_OK_LABEL(done, code, Tcl_GetIntFromObj(interp, v, &l));
									reply->$field = l;
								}
							}
						}}
						uint64_t {subst {
							{
								Tcl_WideInt	l;
								Tcl_Obj*	v = NULL;
								TEST_OK_LABEL(done, code, Tcl_DictObjGet(interp, objv\[3\], f_$field, &v));
								if (v) {
									TEST_OK_LABEL(done, code, Tcl_GetWideIntFromObj(interp, v, &l));
									reply->$field = l;
								}
							}
						}}
						{uint64_t flags *} -
						{uint32_t flags *} {
							lassign $type coretype - flags
							lappend use_extra	use [set ::flagmap_$flags]
							subst {
							{
								Tcl_Obj*	v = NULL;
								TEST_OK_LABEL(done, code, Tcl_DictObjGet(interp, objv\[3\], f_$field, &v));
								if (v)
									TEST_OK_LABEL(done, code, get_${flags}_from_list(interp, v, &reply->$field));
							}
							}
						}
						{struct fuseattr} {
						}
						{struct fuse_ksstatfs} {
						}
						{struct fise_file_lock} {
						}
						{char[]} {
						}
						default {
							error "Unhandled type \"$type\""
						}
					}
				}] \n]

				fprintf(stderr, "Writing fuse_${name}_out: %ld bytes\\n", buflen);
				TEST_OK_LABEL(done, code, fuse_write(interp, fd, buf, buflen));

			done:
				return code;
			}
		}]
		lappend exported_symbols	write_fuse_$name
		append exported_headers		"OBJCMD(write_fuse_$name);\n"

		if {[info exists debug]} {
			set debug	[list debug $debug]
		} else {
			set debug	{}
		}

		list \
			{*}$debug \
			options {-Wall -Werror -gdwarf-5} \
			use		$fuse_io {*}$use_extra \
			export	[list symbols $exported_symbols header $exported_headers] \
			code	$code
	}

	#>>>

	# flagmap_initflag <<<
	file delete -force /tmp/flagmap_initflags; file mkdir /tmp/flagmap_initflags
	set flagmap_initflags	[gen_flag_map -name initflags -headers {stdint.h linux/fuse.h} -debug /tmp/flagmap_initflags -type uint32_t -flags {
		FUSE_ASYNC_READ
		FUSE_POSIX_LOCKS
		FUSE_FILE_OPS
		FUSE_ATOMIC_O_TRUNC
		FUSE_EXPORT_SUPPORT
		FUSE_BIG_WRITES
		FUSE_DONT_MASK
		FUSE_SPLICE_WRITE
		FUSE_SPLICE_MOVE
		FUSE_SPLICE_READ
		FUSE_FLOCK_LOCKS
		FUSE_HAS_IOCTL_DIR
		FUSE_AUTO_INVAL_DATA
		FUSE_DO_READDIRPLUS
		FUSE_READDIRPLUS_AUTO
		FUSE_ASYNC_DIO
		FUSE_WRITEBACK_CACHE
		FUSE_NO_OPEN_SUPPORT
		FUSE_PARALLEL_DIROPS
		FUSE_HANDLE_KILLPRIV
		FUSE_POSIX_ACL
		FUSE_ABORT_ERROR
		FUSE_MAX_PAGES
		FUSE_CACHE_SYMLINKS
		FUSE_NO_OPENDIR_SUPPORT
		FUSE_EXPLICIT_INVAL_DATA
		FUSE_MAP_ALIGNMENT
		FUSE_SUBMOUNTS
		FUSE_HANDLE_KILLPRIV_V2
		FUSE_SETXATTR_EXT
	}]
	#>>>
	# enummap_errno <<<
	file delete -force /tmp/enummap_errno; file mkdir /tmp/enummap_errno
	set enummap_errno	[gen_enum_map -name errno -headers errno.h -debug /tmp/enummap_errno -vals {
		EPERM
		ENOENT
		ESRCH
		EINTR
		EIO
		ENXIO
		E2BIG
		ENOEXEC
		EBADF
		ECHILD
		EAGAIN
		ENOMEM
		EACCES
		EFAULT
		EBUSY
		EEXIST
		EXDEV
		ENODEV
		ENOTDIR
		EISDIR
		ENFILE
		EMFILE
		ENOTTY
		EFBIG
		ENOSPC
		ESPIPE
		EROFS
		EMLINK
		EPIPE
		EDOM
		EDEADLK
		ENAMETOOLONG
		ENOLCK
		ENOSYS
		ENOTEMPTY
		EINVAL
		ERANGE
		EILSEQ
	}]
	#>>>
	# write_fuse_init <<<
	file delete -force /tmp/write_fuse_init; file mkdir /tmp/write_fuse_init
	set write_fuse_init	[gen_fuse_writer -name init -debug /tmp/write_fuse_init -fields {
		uint32_t					major
		uint32_t					minor
		uint32_t					max_readahead
		{uint32_t flags initflags}	flags
		uint16_t					max_background
		uint16_t					congestion_threshold
		uint32_t					max_write
		uint32_t					time_gran
		uint16_t					max_pages
		uint16_t					map_alignment
	}]
	# write_fuse_init >>>

	file delete -force /tmp/fusecmds; file mkdir /tmp/fusecmds
	set fusecmds	[list debug /tmp/fusecmds use $fuse_io use $flagmap_initflags use $enummap_errno use $write_fuse_init options {-Wall -Werror -gdwarf-5} code {//@begin=c@<<<
		#include <unistd.h>
		#include <linux/fuse.h>
		#include <errno.h>
		#include <stdio.h>
		#include <string.h>

		enum lit_objs {
			LIT_OPCODE,
			LIT_UNIQUE,
			LIT_NODEID,
			LIT_UID,
			LIT_GID,
			LIT_PID,
			LIT_TAIL,
			LIT_CUSE_INIT,
			LIT_MAJOR,
			LIT_MINOR,
			LIT_MAX_READAHEAD,
			LIT_FLAGS,
			_LIT_SIZE
		};
		//@end=c@@begin=c@
		const char*	lit_strs[] = {
			"opcode",
			"unique",
			"nodeid",
			"uid",
			"gid",
			"pid",
			"tail",
			"CUSE_INIT",
			"major",
			"minor",
			"max_readahead",
			"flags",
			NULL
		};

		//@end=c@@begin=c@
		#define fuse_opcode_max (FUSE_SYNCFS+1)
		Tcl_Obj*		lit[_LIT_SIZE] = {0};
		Tcl_Obj*		opcodes[fuse_opcode_max] = {0};
		Tcl_Obj*		g_cuse_init = NULL;
		#define fuse_default_readbuf_size	FUSE_MIN_READ_BUFFER
		size_t			readbufsize = fuse_default_readbuf_size;
		static uint8_t	static_readbuf[fuse_default_readbuf_size] = {0};
		static void*	readbuf = static_readbuf;

		typedef int (opcode_decoder)(Tcl_Interp* interp, uint32_t opcode, void* payload, Tcl_Obj* msg);
		opcode_decoder*	decode[fuse_opcode_max] = {0};

		static int decode_fuse_init(Tcl_Interp* interp, uint32_t opcode, void* payload, Tcl_Obj* msg) //<<<
		{
			int						code = TCL_OK;
			struct fuse_init_in*	p = payload;
			Tcl_Obj*				kernflags = NULL;

			TEST_OK_LABEL(done, code, Tcl_DictObjPut(interp, msg, lit[LIT_MAJOR], Tcl_NewWideIntObj(p->major)));
			TEST_OK_LABEL(done, code, Tcl_DictObjPut(interp, msg, lit[LIT_MINOR], Tcl_NewWideIntObj(p->minor)));
			TEST_OK_LABEL(done, code, Tcl_DictObjPut(interp, msg, lit[LIT_MAX_READAHEAD], Tcl_NewWideIntObj(p->max_readahead)));
			TEST_OK_LABEL(done, code, get_list_from_initflags(interp, p->flags, &kernflags));
			TEST_OK_LABEL(done, code, Tcl_DictObjPut(interp, msg, lit[LIT_FLAGS], kernflags));

		done:
			replace_tclobj(&kernflags, NULL);
			return code;
		}

		//>>>

		//@end=c@@begin=c@
		INIT { //<<<
			#define MAP_OPCODE(name) replace_tclobj(&opcodes[name], Tcl_NewStringObj(#name, -1));
			MAP_OPCODE(FUSE_LOOKUP);
			MAP_OPCODE(FUSE_FORGET);
			MAP_OPCODE(FUSE_GETATTR);
			MAP_OPCODE(FUSE_SETATTR);
			MAP_OPCODE(FUSE_READLINK);
			MAP_OPCODE(FUSE_SYMLINK);
			MAP_OPCODE(FUSE_MKNOD);
			MAP_OPCODE(FUSE_MKDIR);
			MAP_OPCODE(FUSE_UNLINK);
			MAP_OPCODE(FUSE_RMDIR);
			MAP_OPCODE(FUSE_RENAME);
			MAP_OPCODE(FUSE_LINK);
			MAP_OPCODE(FUSE_OPEN);
			MAP_OPCODE(FUSE_READ);
			MAP_OPCODE(FUSE_WRITE);
			MAP_OPCODE(FUSE_STATFS);
			MAP_OPCODE(FUSE_RELEASE);
			MAP_OPCODE(FUSE_FSYNC);
			MAP_OPCODE(FUSE_SETXATTR);
			MAP_OPCODE(FUSE_GETXATTR);
			MAP_OPCODE(FUSE_LISTXATTR);
			MAP_OPCODE(FUSE_REMOVEXATTR);
			MAP_OPCODE(FUSE_FLUSH);
			MAP_OPCODE(FUSE_INIT);
			MAP_OPCODE(FUSE_OPENDIR);
			MAP_OPCODE(FUSE_READDIR);
			MAP_OPCODE(FUSE_RELEASEDIR);
			MAP_OPCODE(FUSE_FSYNCDIR);
			MAP_OPCODE(FUSE_GETLK);
			MAP_OPCODE(FUSE_SETLK);
			MAP_OPCODE(FUSE_SETLKW);
			MAP_OPCODE(FUSE_ACCESS);
			MAP_OPCODE(FUSE_CREATE);
			MAP_OPCODE(FUSE_INTERRUPT);
			MAP_OPCODE(FUSE_BMAP);
			MAP_OPCODE(FUSE_DESTROY);
			MAP_OPCODE(FUSE_IOCTL);
			MAP_OPCODE(FUSE_POLL);
			MAP_OPCODE(FUSE_NOTIFY_REPLY);
			MAP_OPCODE(FUSE_BATCH_FORGET);
			MAP_OPCODE(FUSE_FALLOCATE);
			MAP_OPCODE(FUSE_READDIRPLUS);
			MAP_OPCODE(FUSE_RENAME2);
			MAP_OPCODE(FUSE_LSEEK);
			MAP_OPCODE(FUSE_COPY_FILE_RANGE);
			MAP_OPCODE(FUSE_SETUPMAPPING);
			MAP_OPCODE(FUSE_REMOVEMAPPING);
			MAP_OPCODE(FUSE_SYNCFS);
			#undef MAP_OPCODE

			for (int i=0; lit_strs[i]; i++)
				replace_tclobj(&lit[i], Tcl_NewStringObj(lit_strs[i], -1));


			decode[FUSE_INIT] = decode_fuse_init;

			return TCL_OK;
		}

		//@end=c@@begin=c@ >>>
		RELEASE { //<<<
			for (int i=0; i<fuse_opcode_max; i++) replace_tclobj(&opcodes[i], NULL);
			for (int i=0; lit_strs[i]; i++) replace_tclobj(&lit[i], NULL);
			if (readbuf != static_readbuf) {
				ckfree(readbuf);
				readbuf = static_readbuf;
				readbufsize = fuse_default_readbuf_size;
			}
		}

		//@end=c@@begin=c@ >>>
		static int lookup_opcode(Tcl_Interp* interp, uint32_t opcode, Tcl_Obj** opcodeObj) //<<<
		{
			int			code = TCL_OK;

			if (opcode < fuse_opcode_max) {
				replace_tclobj(opcodeObj, opcodes[opcode]);
			} else if (opcode == CUSE_INIT) {
				replace_tclobj(opcodeObj, lit[LIT_CUSE_INIT]);
			} else {
				replace_tclobj(opcodeObj, Tcl_NewWideIntObj(opcode));
			}

		done:
			return code;
		}

		//@end=c@@begin=c@ >>>
		OBJCMD(read_fuse_req) { //<<<
			int						code = TCL_OK;
			int						fd;
			Tcl_Obj*				msg = NULL;
			Tcl_Obj*				opcodeObj = NULL;
			ssize_t					got_header;
			struct fuse_in_header*	req_header = NULL;

			CHECK_ARGS(1, "chan");

			TEST_OK_LABEL(done, code, get_fd_from_obj(interp, objv[1], TCL_READABLE, &fd));
			fprintf(stderr, "Preparing to read from fuse fd: %d\n", fd);

			do {
				int err;
				got_header = read(fd, readbuf, readbufsize);
				err = errno;
				fprintf(stderr, "after read, got_header: %ld, errno: %d, sizeof *req_header: %ld\n", got_header, err, sizeof *req_header);

				if (got_header < (ssize_t)(sizeof *req_header)) {
					fprintf(stderr, "got_header: %ld < sizeof *req_header: %ld\n", got_header, sizeof *req_header);
					if (got_header == -1) {
						if (errno == EINTR) continue;
						fprintf(stderr, "got_header == -1, errno: %d\n", errno);
						THROW_POSIX_LABEL(done, code, "Error calling read on fuse fd");
					} else if (got_header == 0) {
						// EOF
						goto done;
					}
					//@end=c@@begin=c@
					THROW_PRINTF_LABEL(done, code, "Asked for %d bytes, but got %d\n", sizeof *req_header, got_header);
				} else {
					fprintf(stderr, "got_header: %ld >= sizeof *req_header: %ld\n", got_header, sizeof *req_header);
				}
			} while(0);
			//@end=c@@begin=c@
			if (got_header == -1) THROW_ERROR_LABEL(done, code, "Read header error, shouldn't happen");

			req_header = readbuf;
			if (got_header < req_header->len) {
				const ssize_t	taillen = req_header->len - sizeof *req_header;
				ssize_t			remain = req_header->len - got_header;

				if (remain > readbufsize) {
					const size_t newsize = req_header->len > FUSE_MIN_READ_BUFFER ? req_header->len : FUSE_MIN_READ_BUFFER;
					if (readbuf == static_readbuf) {
						uint8_t* newreadbuf = ckalloc(newsize);
						memcpy(newreadbuf, readbuf, got_header);
						readbuf = newreadbuf;
					} else {
						readbuf = ckrealloc(readbuf, newsize);
					}
					readbufsize = newsize;
					req_header = readbuf;
				}
			}

			if (got_header > req_header->len)
				fprintf(stderr, "Read more than expected (%ld): %ld\n", req_header->len, got_header);


			ssize_t	remain = req_header->len - got_header;

			if (remain > 0) {
				do {
					const ssize_t got_tail = read(fd, readbuf+got_header, readbufsize-got_header);
					fprintf(stderr, "got_tail: %ld, asked for: %ld, got_header: %ld, sizeof req_header: %ld\n", got_tail, remain, got_header, sizeof *req_header);

					if (got_tail <= remain) {
						if (got_tail == -1) {
							if (errno = EINTR) continue;
							THROW_POSIX_LABEL(done, code, "Error calling read on fuse fd");
						} else if (got_tail == 0) {
							// EOF
							goto done;
						}
						THROW_PRINTF_LABEL(done, code, "Asked for %d bytes, but got %d\n", readbufsize-got_header, got_tail);
					}
				} while(0);
			}

			if (req_header->opcode = FUSE_INIT) {
				struct fuse_init_in*	fuse_init = readbuf+sizeof *req_header;
				fprintf(stderr, "FUSE_INIT, major: %d, minor: %d, max_readahead: %d, flags: 0x%08x\n",
					fuse_init->major, fuse_init->minor, fuse_init->max_readahead, fuse_init->flags);
			}

			replace_tclobj(&msg, Tcl_NewDictObj());

			TEST_OK_LABEL(done, code, lookup_opcode(interp, req_header->opcode, &opcodeObj));
			TEST_OK_LABEL(done, code, Tcl_DictObjPut(interp, msg, lit[LIT_OPCODE], opcodeObj));
			TEST_OK_LABEL(done, code, Tcl_DictObjPut(interp, msg, lit[LIT_UNIQUE], Tcl_NewWideIntObj(req_header->unique)));
			TEST_OK_LABEL(done, code, Tcl_DictObjPut(interp, msg, lit[LIT_NODEID], Tcl_NewWideIntObj(req_header->nodeid)));
			TEST_OK_LABEL(done, code, Tcl_DictObjPut(interp, msg, lit[LIT_UID], Tcl_NewWideIntObj(req_header->uid)));
			TEST_OK_LABEL(done, code, Tcl_DictObjPut(interp, msg, lit[LIT_GID], Tcl_NewWideIntObj(req_header->gid)));
			TEST_OK_LABEL(done, code, Tcl_DictObjPut(interp, msg, lit[LIT_PID], Tcl_NewWideIntObj(req_header->pid)));
			TEST_OK_LABEL(done, code, Tcl_DictObjPut(interp, msg, lit[LIT_TAIL], Tcl_NewByteArrayObj(readbuf+sizeof *req_header, req_header->len-sizeof(*req_header))));

			if (req_header->opcode < fuse_opcode_max && decode[req_header->opcode])
				TEST_OK_LABEL(done, code, (decode[req_header->opcode])(interp, req_header->opcode, readbuf+sizeof *req_header, msg));

			Tcl_SetObjResult(interp, msg);

		done:
			replace_tclobj(&msg, NULL);
			replace_tclobj(&opcodeObj, NULL);

			return code;
		}

		//>>>
		OBJCMD(write_error) { //<<<
			int				code = TCL_OK;
			Tcl_WideInt		unique;
			int				err;
			int				fd;

			CHECK_ARGS(3, "fd unique errno");

			TEST_OK_LABEL(done, code, get_fd_from_obj(interp, objv[1], TCL_WRITABLE, &fd));
			TEST_OK_LABEL(done, code, Tcl_GetWideIntFromObj(interp, objv[2], &unique))
			TEST_OK_LABEL(done, code, get_errno_from_obj(interp, objv[3], &err));

			struct fuse_out_header	hdr = {
				.len		= sizeof hdr,
				.error		= err,
				.unique		= unique
			};

			TEST_OK_LABEL(done, code, fuse_write(interp, fd, &hdr, sizeof hdr));

		done:
			return TCL_OK;
		}

		//>>>
	//@end=c@>>>}]

	chan event $fd readable [list apply {fd {
		global fusecmds

		try {
			puts "read fuse msg: [timerate {
			set msg	[jitc::capply $fusecmds read_fuse_req $fd]
			} 1 1]"

			if {[dict size $msg] == 0} {
				# eof
				cleanup
				return
			}

			set seen	{}
			puts "Received fuse msg:\n\t[join [lmap v {opcode unique nodeid uid gid pid} {
				dict set seen $v 1
				format {%8s: (%s)} $v [dict get $msg $v]
			}] \n\t]"
			puts stderr "payload: [regexp -all -inline .. [binary encode hex [dict get $msg tail]]]"
			dict set seen tail 1
			dict for {k v} $msg {
				if {[dict exists $seen $k]} continue
				puts [format {%12s: (%s)} $k [dict get $msg $k]]
			}

			switch -exact -- [dict get $msg opcode] {
				FUSE_INIT {
					if {[incr ::fuse_init_count] > 2} {error "FUSE_INIT loop, bailing"}

					if {[dict get $msg major] > 7} {
						# TODO: reply with just major 7
						error "Major protocol version mismatch and negotiation not supported"
					} elseif {[dict get $msg major] < 7} {
						error "Major protocol version from kernel is too old"
					} elseif {[dict get $msg minor] < 34} {
						error "Minor version too old"
					}
					jitc::capply $fusecmds write_fuse_init $fd [dict get $msg unique] [dict create \
						major					7 \
						minor					34 \
						max_readahead			[expr {4*1048576}] \
						flags					{
							FUSE_ATOMIC_O_TRUNC
							FUSE_BIG_WRITES
							FUSE_ABORT_ERROR
						} \
						max_background			8 \
						congestion_threshold	4 \
						max_read				0 \
						max_write				[expr {4*1048576}] \
						time_gran				1000 \
					]
				}
				

				default {
					error "opcode ([dict get $msg opcode]) not handled"
				}
			}

			#set i [read $fd 4]
			#binary scan $i n len
			#puts stderr "Read len: $len"
			#set rest	[read $fd [expr {$len-4}]]
			#binary scan $rest nmmnnnna* opcode unique nodeid uid gid pid padding tail
			#foreach v {opcode unique nodeid uid gid pid} {
			#	puts stderr "$v: $v"
			#}
			#puts stderr "payload: [regexp -all -inline .. [binary encode hex $tail]]"
		} on error {errmsg options} {
			puts "fuse fd readable error [dict get $options -errorcode]: [dict get $options -errorinfo]"
			if {[info exists msg] && [dict exists $msg unique]} {
				puts stderr "Writing error reply"
				jitc::capply $fusecmds write_error $fd [dict get $msg unique] EINVAL
			}
			cleanup
			return -options $options $errmsg
		}
	}} $fd]

	package require jitclib::tempdir

	set tempdir	[jitc::capply $::jitclib::tempdir tempdir fuseraw_test_]

	file delete -force /tmp/dbg
	file mkdir /tmp/dbg
	if 1 {
		jitc::capply {debug /tmp/dbg options {-Wall -Werror -gdwarf-5} code {//@begin=c@
			#include <sys/mount.h>
			#include <stdio.h>
			#include <unistd.h>
			#include <fcntl.h>

			OBJCMD(do_mount) {
				int			code = TCL_OK;
				Tcl_Obj*	fsargs = NULL;
				Tcl_WideInt	fdw;
				int fd;
				ClientData fd_cdata;
				Tcl_Channel	chan;

				CHECK_ARGS(2, "chan mountpoint");

				int mode;
				chan = Tcl_GetChannel(interp, Tcl_GetString(objv[1]), &mode);
				if (chan == NULL) goto done;
				if (mode & TCL_READABLE == 0 || mode & TCL_WRITABLE == 0)
					THROW_ERROR_LABEL(done, code, "chan must be readable and writable");
				int mountpoint_len;
				const char* mountpoint = Tcl_GetStringFromObj(objv[2], &mountpoint_len);

				TEST_OK_LABEL(done, code, Tcl_GetChannelHandle(chan, TCL_READABLE, &fd_cdata));
				fdw = (Tcl_WideInt)fd_cdata;
				fd = fdw;
				fcntl(fd, F_SETFD, 0);

				replace_tclobj(&fsargs, Tcl_ObjPrintf("fd=%d,rootmode=%o,user_id=1000,group_id=1000", fd, S_IFDIR));

				fprintf(stderr, "Calling mount(), mountpoint: (%s), fsargs: (%s)\n", mountpoint, Tcl_GetString(fsargs));
				//const int mount_rc = mount("fuseraw", mountpoint, "fuse", MS_NOEXEC | MS_NOSUID, Tcl_GetString(fsargs));
				const int mount_rc = mount("fuse", mountpoint, "fuse", 0, Tcl_GetString(fsargs));
				if (mount_rc == -1)
					THROW_POSIX_LABEL(done, code, "Error calling mount");

			done:
				replace_tclobj(&fsargs, NULL);
				return code;
			}
		//@end=c@}} do_mount $fd $tempdir
	} else {
		set native_fd	[jitc::capply $lookup_fd native $fd]
		puts stderr "native_fd: ($native_fd)"
		try {
			exec mount.fuse3 fuseraw#foo -o fd=$native_fd $tempdir
		} on error {errmsg options} {
			puts stderr "mount error: $options"
		}
	}

	set tempdir
}]

#puts stderr "Calling glob $tempdir/*"
#puts stderr [glob $tempdir/*]
after 3000

thread::release $fs_tid

puts stderr "Waiting for fs thread"
thread::join $fs_tid

#puts stderr "Unmounting ($mountpoint)"
#exec umount $mountpoint
#puts stderr "Unmounted"

# vim: ft=tcl foldmethod=marker foldmarker=<<<,>>> ts=4 shiftwidth=4
# TODO: syn sync minlines=1000
