proc readfile fn {
	set h	[open $fn]
	try {read $h} finally {close $h}
}

proc writefile {fn dat} {
	set h	[open $fn w]
	try {puts -nonewline $h $dat} finally {close $h}
}

puts "uid_map: [exec ls -l /proc/self/uid_map]"
#writefile /proc/self/uid_map "0 0 4294967295\n"
#writefile /proc/self/gid_map "0 0 4294967295\n"

puts "user: [exec id -u]"
#puts "processes: [exec ps -aux]"
puts "pid: [pid]"
puts "from ps: [exec ps -up [pid]]"
puts "uid_map: ([readfile /proc/self/uid_map])"
puts "gid_map: ([readfile /proc/self/gid_map])"
#puts "ls -l /tmp:\n[exec ls -l /tmp]"

package require jitc

puts "hello ($argv0), args: ($argv)"

if 0 {
set mountinfo	[lmap line [split [readfile /proc/self/mountinfo] \n] {
	if {![string match /tmp/memfs_* [lindex $line 4]]} continue
	set line
}]
puts "mountinfo: ($mountinfo)"
set mountpoint	[lindex $mountinfo 0 4]
lassign [split [lindex $mountinfo 0 2] :] major minor
set devnum		[expr {($major << 8) + $minor}]
puts "dev: $major:$minor, num: $devnum"

puts "glob: [timerate {puts "glob: [glob $mountpoint/*]"} 1 1], benchmark: [timerate {glob $mountpoint/*}]"
puts "readfile: [timerate {puts "readfile: ([readfile $mountpoint/foo])"} 1 1], benchmark: [timerate {readfile $mountpoint/foo}]"

# warmup
exec ls / $mountpoint

puts "ls: [timerate {
puts "ls $mountpoint:\n[exec ls -al $mountpoint]"
} 1 1]"
puts "cat [timerate {
puts "cat $mountpoint/foo: ([exec cat $mountpoint/foo])"
} 1 1]"
puts "ls /: [timerate {exec ls /} 1 1], benchmark: [timerate {exec ls /}]"
}
file delete -force -- /tmp/jitc_debugfiles
file mkdir /tmp/jitc_debugfiles
proc unshare args { #<<<
	jitc::capply {define _GNU_SOURCE debug /tmp/jitc_debugfiles options {-Wall -Werror -g} code {//@begin=c@
		#include <stdio.h>
		#include <sched.h>
		#include <linux/sched.h>

		OBJCMD(Unshare) {
			int			code = TCL_OK;

			static const char* flagstr[] = {
				"CLONE_FILES",
				"CLONE_FS",
				"CLONE_NEWCGROUP",
				"CLONE_NEWIPC",
				"CLONE_NEWNET",
				"CLONE_NEWNS",
				"CLONE_NEWPID",
				"CLONE_NEWTIME",
				"CLONE_NEWUSER",
				"CLONE_NEWUTS",
				"CLONE_SYSVSEM",
				"CLONE_THREAD",
				"CLONE_SIGHAND",
				"CLONE_VM",
				NULL
			};
			//@end=c@@begin=c@
			int flagmap[] = {
				CLONE_FILES,
				CLONE_FS,
				CLONE_NEWCGROUP,
				CLONE_NEWIPC,
				CLONE_NEWNET,
				CLONE_NEWNS,
				CLONE_NEWPID,
				CLONE_NEWTIME,
				CLONE_NEWUSER,
				CLONE_NEWUTS,
				CLONE_SYSVSEM,
				CLONE_THREAD,
				CLONE_SIGHAND,
				CLONE_VM
			};
			//@end=c@@begin=c@
			int flags = 0;

			for (int i=1; i<objc; i++) {
				int flagidx;

				TEST_OK_LABEL(done, code, Tcl_GetIndexFromObj(interp, objv[i], flagstr, "flag", TCL_EXACT, &flagidx));
				
				fprintf(stderr, "Adding flag: %s: 0x%x\n", flagstr[flagidx], flagmap[flagidx]);
				flags |= flagmap[flagidx];
			}
			//@end=c@@begin=c@

			fprintf(stderr, "Combined flags: 0x%x\n", flags);
			if (-1 == unshare(flags))
				THROW_POSIX_LABEL(done, code, "Error calling unshare");

		done:
			return code;
		}
	//@end=c@}} Unshare {*}$args
}

#>>>

jitc::capply [list code {//@begin=c@
#include <linux/fuse.h>
#include <stdio.h>
OBJCMD(t) {
	int			code = TCL_OK;
	CHECK_ARGS(0, "");
	fprintf(stderr, "Test command\n");
done:
	return code;
}
//@end=c@}] t

if 0 {
#unshare CLONE_NEWNS CLONE_NEWUSER
unshare CLONE_NEWNS
puts "Called unshare"
#writefile /proc/self/uid_map "0 0 4294967295\n"
#writefile /proc/self/gid_map "0 0 4294967295\n"
puts "Wrote uid_map and gid_map"
#unshare CLONE_NEWNS
}

package require Thread
set fs_tid	[thread::create -joinable -preserved {proc cleanup {} {}; thread::wait; cleanup}]
thread::send $fs_tid $::_threadinit
thread::send $fs_tid [list set ::_threadinit $::_threadinit]
set tempdir	[thread::send $fs_tid {
	package require jitc
	package require parse_args
	namespace import ::parse_args::*

	proc cleanup {} { #<<<
		global fd tempdir epoll_tid

		puts stderr "In fs_tid cleanup"

		if {[info exists epoll_tid]} {
			thread::send -async $epoll_tid [list set running 0]
			thread::release $epoll_tid
			unset epoll_tid
		}

		set mountpoint_busy	0
		try {
			puts stderr "Calling umount $tempdir"
			exec umount -f $tempdir
		} trap CHILDSTATUS {errmsg options} {
			lassign [dict get $options -errorcode] - pid rc
			if {$rc == 32} {
				set mountpoint_busy	1
			}
		} on error {errmsg options} {
			puts stderr "umount err: $options"
		}
		#puts stderr "Processing event queue after umount"
		#update

		if {[info exists fd]} {
			puts stderr "Closing fd"
			fusecmds close_fuse $fd
			unset fd
		}

		if {!$mountpoint_busy && [info exists tempdir]} {
			puts stderr "Removing mountpoint dir $tempdir"
			file delete -force $tempdir
		}
		puts stderr "Leaving fs_tid cleanup"
	}

	#>>>

	# epoll thread <<<
	set epoll_tid	[thread::create -preserved]
	thread::send $epoll_tid	$::_threadinit
	thread::send $epoll_tid {
		package require jitc

		file delete -force /tmp/fuse_epoll_fd; file mkdir /tmp/fuse_epoll_fd
		interp alias {} poll_fd {} jitc::capply [list \
			debug		/tmp/fuse_epoll_fd \
			options		{-Wall -Werror -g} \
			code {//@begin=c@
				#include <sys/epoll.h>
				#include <unistd.h>
				#include <errno.h>

				enum {
					LIT_TRUE,
					LIT_FALSE,
					_LIT_END
				};
				//@end=c@@begin=c@
				static const char*	litstrs[] = {
					"1",
					"0",
					NULL
				};

				//@end=c@@begin=c@
				static Tcl_Obj*	lit[_LIT_END] = {0};

				//@end=c@@begin=c@
				INIT {
					for (int i=0; litstrs[i]; i++)
						replace_tclobj(&lit[i], Tcl_NewStringObj(litstrs[i], -1));

					return TCL_OK;
				}

				RELEASE {
					for (int i=0; litstrs[i]; i++)
						replace_tclobj(&lit[i], NULL);
				}

				OBJCMD(waitfor_fd) //<<<
				{
					int				code = TCL_OK;
					int				timeout;
					int				epollfd = 0;
					int				fd;

					CHECK_ARGS(2, "fd timeout_ms");

					TEST_OK_LABEL(done, code, Tcl_GetIntFromObj(interp, objv[1], &fd));
					TEST_OK_LABEL(done, code, Tcl_GetIntFromObj(interp, objv[2], &timeout));

					epollfd = epoll_create1(EPOLL_CLOEXEC);
					if (epollfd == -1) THROW_POSIX_LABEL(done, code, "Error creating epollfd");
					const int			max_events = 100;
					struct epoll_event	events[max_events];
					struct epoll_event	ev;

					ev.events = EPOLLIN | EPOLLET;
					ev.data.ptr = NULL;
					epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &ev);

					for (;;) {
						const int nfds = epoll_wait(epollfd, events, max_events, timeout);
						if (-1 == nfds) {
							if (errno == EINTR) continue;
							THROW_POSIX_LABEL(done, code, "Error from epoll_wait");
						}

						// Return true if we timed out
						Tcl_SetObjResult(interp, nfds == 0 ? lit[LIT_TRUE] : lit[LIT_FALSE]);
						goto done;
					}

				done:
					if (epollfd) {
						close(epollfd);
						epollfd = 0;
					}
					return code;
				}

				//>>>
			//@end=c@} \
		]

		proc poll {fd cb} {
			global running

			set timeout	[poll_fd waitfor_fd $fd 5000]
			puts stderr "epoll thread epoll_fd returned: $timeout"
			if {!$timeout && $running} {
				uplevel #0 $cb
			}
			if {$running} {
				after idle [list poll $fd $cb]
			}
		}

		set running 1
	}
	# epoll thread >>>

	proc readfile fn {
		set h	[open $fn r]
		try {read $h} finally {close $h}
	}

	# fuse_io <<<
	file delete -force /tmp/fuse_io; file mkdir /tmp/fuse_io
	set fuse_io	{debug /tmp/fuse_io options {-Wall -Werror -g} export {
			symbols	{fuse_write}
			header	{
				#include <unistd.h>
				int fuse_write(Tcl_Interp* interp, int fd, void* buf, size_t buflen);
			}
		}
		code {//@begin=c@
			#include <linux/fuse.h>
			#include <unistd.h>
			#include <errno.h>

			int fuse_write(Tcl_Interp* interp, int fd, void* buf, size_t len) //<<<
			{
				int		code = TCL_OK;
				ssize_t	written = 0;

				do {
					const ssize_t wrote = write(fd, (void*)buf+written, len - written);
					if (wrote == -1) {
						if (errno = EINTR) continue;
						THROW_POSIX_LABEL(done, code, "Error calling write on fuse fd");
					}
					written += wrote;
					if (written < len) continue;
				} while(0);

			done:
				return code;
			}

			//>>>@end=c@@begin=c@
		//@end=c@}
	}
	# fuse_io >>>

	proc gen_flag_map args { #<<<
		parse_args $args {
			-headers	{-default {} -# {Headers to include that contain the required definitions}}
			-type		{-default int -# {The type of the mapped value}}
			-flags		{-required -# {A list of flags to generate mappings for}}
			-debug		{}
			-name		{-required -# {The map name}}
		}
		# TODO: validate that each element of $flags is a valid c identifier (syntactically)
		# TODO: validate that each element of $headers is a valid filename (syntactically)
		# TODO: validate that type and name are valid c symbols (syntactically)

		set code	{}

		set size	[llength $flags]

		set exported_symbols	{}
		set exported_headers	{}

		foreach header $headers {
			append exported_headers	"#include <$header>\n"
		}

		append code [subst {static const char* strs\[\] = {[join [lmap f $flags {
			format {"%s"} $f
		}] ,\n\t],\n\tNULL\n};}] \n
		append code [subst {static const $type map\[\] = {[join [lmap f $flags {
			format {%s} $f
		}] ,\n\t]\n};}] \n
		append code [subst {static Tcl_Obj* objs\[$size\] = {0};}] \n

		set i	-1
		append code "INIT \{\n\t[join [lmap f $flags {
			format {replace_tclobj(&objs[%d], Tcl_NewStringObj("%s", %d));} [incr i] $f [string length $f]
		}] \n\t]\n\treturn TCL_OK;\n\}\n\n"
		append code [subst {RELEASE {\n\tfor (int i=0; i<$size; i++) replace_tclobj(&objs\[i\], NULL);\n}}] \n\n

		append code [subst {int get_${name}_from_list(Tcl_Interp* interp, Tcl_Obj* list, $type* res)
{
	int code = TCL_OK;
	int idx;
	Tcl_Obj**	ov = NULL;
	int			oc;
	$type		acc = 0;
	TEST_OK_LABEL(done, code, Tcl_ListObjGetElements(interp, list, &oc, &ov));
	for (int i=0; i<oc; i++) {
		TEST_OK_LABEL(done, code, Tcl_GetIndexFromObj(interp, ov\[i\], strs, "$name", TCL_EXACT, &idx));
		acc |= map\[idx\];
	}
	*res = acc;

done:
	return code;
}}] \n\n
		lappend exported_symbols get_${name}_from_list
		append exported_headers "int get_${name}_from_list(Tcl_Interp* interp, Tcl_Obj* list, $type* res);\n"

		append code [subst {int get_list_from_${name}(Tcl_Interp* interp, $type flags, Tcl_Obj** list)
{
	int			code = TCL_OK;
	Tcl_Obj*	acc = NULL;

	replace_tclobj(&acc, Tcl_NewListObj(0, NULL));

	for (int i=0; i<$size; i++)
		if ((flags & map\[i\]) == map\[i\])
			TEST_OK_LABEL(done, code, Tcl_ListObjAppendElement(interp, acc, objs\[i\]));

	replace_tclobj(list, acc);
done:
	replace_tclobj(&acc, NULL);
	return code;
}}] \n\n
		lappend exported_symbols get_list_from_$name
		append exported_headers "int get_list_from_${name}(Tcl_Interp* interp, $type flags, Tcl_Obj** list);\n"

		if {[info exists debug]} {
			set debug	[list debug $debug]
		} else {
			set debug	{}
		}

		list {*}$debug options {-Wall -Werror -g} code $code export [list symbols $exported_symbols header $exported_headers]
	}

	#>>>
	proc gen_enum_map args { #<<<
		parse_args $args {
			-headers	{-default {} -# {Headers to include that contain the required definitions}}
			-type		{-default int -# {The type of the mapped value}}
			-vals		{-required -# {A list of enum values to generate mappings for}}
			-debug		{}
			-name		{-required -# {The map name}}
		}
		# TODO: validate that each element of $vals is a valid c identifier (syntactically)
		# TODO: validate that each element of $headers is a valid filename (syntactically)
		# TODO: validate that type and name are valid c symbols (syntactically)

		set code	{}

		set size	[llength $vals]

		set exported_symbols	{}
		set exported_headers	{}

		foreach header $headers {
			append exported_headers	"#include <$header>\n"
		}

		append code [subst {static const char* strs\[\] = {[join [lmap v $vals {
			format {"%s"} $v
		}] ,\n\t],\n\tNULL\n};}] \n
		append code [subst {static const $type map\[\] = {[join [lmap v $vals {
			format {%s} $v
		}] ,\n\t]\n};}] \n
		append code [subst {static Tcl_Obj* objs\[$size\] = {0};}] \n

		set i	-1
		append code "INIT \{\n\t[join [lmap v $vals {
			format {replace_tclobj(&objs[%d], Tcl_NewStringObj("%s", %d));} [incr i] $v [string length $v]
		}] \n\t]\n\treturn TCL_OK;\n\}\n\n"
		append code [subst {RELEASE {\n\tfor (int i=0; i<$size; i++) replace_tclobj(&objs\[i\], NULL);\n}}] \n\n

		append code [subst {int get_${name}_from_obj(Tcl_Interp* interp, Tcl_Obj* obj, $type* res)
{
	int code = TCL_OK;
	int idx;
	TEST_OK_LABEL(done, code, Tcl_GetIndexFromObj(interp, obj, strs, "$name", TCL_EXACT, &idx));
	*res = map\[idx\];

done:
	return code;
}}] \n\n
		lappend exported_symbols get_${name}_from_obj
		append exported_headers "int get_${name}_from_obj(Tcl_Interp* interp, Tcl_Obj* obj, $type* res);\n"

		append code [subst {int get_obj_from_${name}(Tcl_Interp* interp, $type val, Tcl_Obj** obj)
{
	int			code = TCL_OK;

	for (int i=0; i<$size; i++) {
		if (map\[i\] == val) {
			replace_tclobj(obj, objs\[i\]);
			goto done;
		}
	}

	// TODO: determine printf format for $type
	THROW_PRINTF_LABEL(done, code, "Unhandled $type value: %d\\n", val);

done:
	return code;
}}] \n\n
		lappend exported_symbols get_obj_from_$name
		append exported_headers "int get_obj_from_${name}(Tcl_Interp* interp, $type val, Tcl_Obj** obj);\n"

		if {[info exists debug]} {
			set debug	[list debug $debug]
		} else {
			set debug	{}
		}

		list {*}$debug options {-Wall -Werror -g} code $code export [list symbols $exported_symbols header $exported_headers]
	}

	#>>>
	proc gen_struct_converter args { #<<<
		global fuse_io

		parse_args $args {
			-name		{-required}
			-debug		{}
			-headers	{-default {}}
			-fields		{-required}
		}

		set exported_symbols	{}
		set exported_headers	{}
		set code				{}
		set use_extra			{}

		foreach header $headers {
			append exported_headers	"#include <$header>\n"
		}

		set requirements_seen	{}
		set require {var {
			upvar 1 requirements_seen requirements_seen  use_extra use_extra
			if {![dict exists $requirements_seen $var]} {
				lappend use_extra	use [set $var]
				dict set requirements_seen $var 1
			}
		}}

		append code [subst {
			[join [lmap {type field} $fields {subst {
				Tcl_Obj*	f_$field = NULL;
			}}] \n]

			INIT {
				[join [lmap {type field} $fields {subst {
					replace_tclobj(&f_$field, Tcl_NewStringObj("$field", [string length $field]));
				}}] \n]
				return TCL_OK;
			}

			RELEASE {
				[join [lmap {type field} $fields {subst {
					replace_tclobj(&f_$field, NULL);
				}}] \n]
			}

			int dict_to_struct_${name}(Tcl_Interp* interp, Tcl_Obj* dict, struct $name* out)
			{
				int				code = TCL_OK;
				Tcl_Obj*		k = NULL;
				Tcl_Obj*		v = NULL;
				const size_t	buflen = sizeof(struct $name);
				uint8_t			buf\[buflen\];

				[join [lmap {type field} $fields {
					switch -glob -- $type {
						uint16_t -
						int32_t -
						uint32_t {subst {
							{
								int			l;
								Tcl_Obj*	v = NULL;
								TEST_OK_LABEL(done, code, Tcl_DictObjGet(interp, dict, f_$field, &v));
								if (v) {
									TEST_OK_LABEL(done, code, Tcl_GetIntFromObj(interp, v, &l));
									out->$field = l;
								}
							}
						}}
						uint64_t {subst {
							{
								Tcl_WideInt	l;
								Tcl_Obj*	v = NULL;
								TEST_OK_LABEL(done, code, Tcl_DictObjGet(interp, dict, f_$field, &v));
								if (v) {
									TEST_OK_LABEL(done, code, Tcl_GetWideIntFromObj(interp, v, &l));
									out->$field = l;
								}
							}
						}}
						{uint64_t flags *} -
						{uint32_t flags *} {
							lassign $type coretype - flags
							apply $require ::flagmap_$flags
							subst {
							{
								Tcl_Obj*	v = NULL;
								TEST_OK_LABEL(done, code, Tcl_DictObjGet(interp, dict, f_$field, &v));
								if (v)
									TEST_OK_LABEL(done, code, get_${flags}_from_list(interp, v, &out->$field));
							}
							}
						}
						{struct *} {
							set structname	[lindex $type 1]
							apply $require ::struct_$structname
							subst {
							{
								Tcl_Obj*	v = NULL;
								TEST_OK_LABEL(done, code, Tcl_DictObjGet(interp, dict, f_$field, &v));
								if (v)
									TEST_OK_LABEL(done, code, dict_to_struct_${structname}(interp, v, &out->$field));
							}
							}
						}
						{string *} {
							set lenfield	[lindex $type 1]
							subst {
							{
								Tcl_Obj*	v = NULL;
								int			len;

								TEST_OK_LABEL(done, code, Tcl_DictObjGet(interp, dict, f_$field, &v));
								out->$field = Tcl_GetStringFromObj(v, &len);
								out->$lenfield = len;
							}
						}}
						default {
							error "Unhandled type \"$type\""
						}
					}
				}] \n]

			done:
				return code;
			}

			int struct_${name}_to_dict(Tcl_Interp* interp, struct $name* s, Tcl_Obj** out)
			{
				int				code = TCL_OK;
				Tcl_Obj*		d = NULL;

				replace_tclobj(&d, Tcl_NewDictObj());

				[join [lmap {type field} $fields {
					switch -glob -- $type {
						int16_t - uint16_t - uint32_t - int32_t - int64_t - uint64_t {subst {
							TEST_OK_LABEL(done, code, Tcl_DictObjPut(interp, d, f_$field, Tcl_NewWideIntObj(s->$field)));
						}}
						{uint64_t flags *} -
						{uint32_t flags *} {
							lassign $type coretype - flags
							apply $require ::flagmap_$flags
							subst {
							{
								Tcl_Obj*	t = NULL;
								TEST_OK_LABEL(done$field, code, get_list_from_${flags}(interp, s->$field, &t));
								TEST_OK_LABEL(done$field, code, Tcl_DictObjPut(interp, d, f_$field, t));
							done$field:
								replace_tclobj(&t, NULL);
								if (code != TCL_OK) goto done;
							}
							}
						}
						{struct *} {
							set structname	[lindex $type 1]
							apply $require ::struct_$structname
							subst {
							{
								Tcl_Obj*	t = NULL;
								TEST_OK_LABEL(done$field, code, struct_${structname}_to_dict(interp, &s->$field, &t));
								TEST_OK_LABEL(done$field, code, Tcl_DictObjPut(interp, d, f_$field, t));
							done$field:
								replace_tclobj(&t, NULL);
								if (code != TCL_OK) goto done;
							}
							}
						}
						{string *} {
							set lenfield	[lindex $type 1]
							subst {
							TEST_OK_LABEL(done, code, Tcl_DictObjPut(interp, d, f_$field, Tcl_NewStringObj(s->$field, s->$lenfield)));
							}
						}
						default {
							error "Unhandled type \"$type\""
						}
					}
				}] \n]
				replace_tclobj(out, d);

			done:
				replace_tclobj(&d, NULL);
				return code;
			}
		}]
		lappend exported_symbols	dict_to_struct_$name struct_${name}_to_dict
		append exported_headers		"int dict_to_struct_${name}(Tcl_Interp* interp, Tcl_Obj* dict, struct $name* out);\n"
		append exported_headers		"int struct_${name}_to_dict(Tcl_Interp* interp, struct $name* s, Tcl_Obj** out);\n"

		if {[info exists debug]} {
			set debug	[list debug $debug]
		} else {
			set debug	{}
		}

		list \
			{*}$debug \
			options {-Wall -Werror -g} \
			{*}$use_extra \
			export	[list symbols $exported_symbols header $exported_headers] \
			code	$code
	}

	#>>>
	proc gen_fuse_writer args { #<<<
		global fuse_io

		parse_args $args {
			-name			{-required}
			-debug			{}
			-replystruct	{-required}
		}

		set exported_symbols	{}
		set exported_headers	{}
		set code				{}
		set use_extra			{}

		append code [subst {
			OBJCMD(write_fuse_$name) {
				int				code = TCL_OK;
				int				fd;
				Tcl_WideInt		unique;
				const size_t	buflen = sizeof(struct fuse_out_header) + sizeof(struct $replystruct);
				uint8_t			buf\[buflen\];
				struct fuse_out_header*	hdr = (void*)buf;
				struct $replystruct*	reply = ((void*)buf)+sizeof(struct fuse_out_header);

				fprintf(stderr, "In write_fuse_$name\\n");
				CHECK_ARGS(3, "fd unique msg");

				TEST_OK_LABEL(done, code, Tcl_GetIntFromObj(interp, objv\[1\], &fd));
				TEST_OK_LABEL(done, code, Tcl_GetWideIntFromObj(interp, objv\[2\], &unique));

				*hdr = (struct fuse_out_header){
					.len	= buflen,
					.unique	= unique
				};
				*reply = (struct $replystruct){0};
				TEST_OK_LABEL(done, code, dict_to_struct_${replystruct}(interp, objv\[3\], reply));

				fprintf(stderr, "Writing $replystruct: %ld bytes\\n", buflen);
				TEST_OK_LABEL(done, code, fuse_write(interp, fd, buf, buflen));

			done:
				return code;
			}
		}]
		lappend exported_symbols	write_fuse_$name
		append exported_headers		"OBJCMD(write_fuse_$name);\n"

		if {[info exists debug]} {
			set debug	[list debug $debug]
		} else {
			set debug	{}
		}

		list \
			{*}$debug \
			options {-Wall -Werror -g} \
			use		$fuse_io \
			use		[set ::struct_$replystruct] \
			export	[list symbols $exported_symbols header $exported_headers] \
			code	$code
	}

	#>>>

	# flagmap_initflags <<<
	file delete -force /tmp/flagmap_initflags; file mkdir /tmp/flagmap_initflags
	set flagmap_initflags	[gen_flag_map -name initflags -headers {stdint.h linux/fuse.h} -debug /tmp/flagmap_initflags -type uint32_t -flags {
		FUSE_ASYNC_READ
		FUSE_POSIX_LOCKS
		FUSE_FILE_OPS
		FUSE_ATOMIC_O_TRUNC
		FUSE_EXPORT_SUPPORT
		FUSE_BIG_WRITES
		FUSE_DONT_MASK
		FUSE_SPLICE_WRITE
		FUSE_SPLICE_MOVE
		FUSE_SPLICE_READ
		FUSE_FLOCK_LOCKS
		FUSE_HAS_IOCTL_DIR
		FUSE_AUTO_INVAL_DATA
		FUSE_DO_READDIRPLUS
		FUSE_READDIRPLUS_AUTO
		FUSE_ASYNC_DIO
		FUSE_WRITEBACK_CACHE
		FUSE_NO_OPEN_SUPPORT
		FUSE_PARALLEL_DIROPS
		FUSE_HANDLE_KILLPRIV
		FUSE_POSIX_ACL
		FUSE_ABORT_ERROR
		FUSE_MAX_PAGES
		FUSE_CACHE_SYMLINKS
		FUSE_NO_OPENDIR_SUPPORT
		FUSE_EXPLICIT_INVAL_DATA
		FUSE_MAP_ALIGNMENT
		FUSE_SUBMOUNTS
		FUSE_HANDLE_KILLPRIV_V2
		FUSE_SETXATTR_EXT
	}]
	#>>>
	# flagmap_getattr <<<
	set flagmap_getattr	[gen_flag_map -name getattr -headers {stdint.h linux/fuse.h} -type uint32_t -flags {
		FUSE_GETATTR_FH
	}]
	#>>>
	# flagmap_attr <<<
	set flagmap_attr	[gen_flag_map -name attr -headers {stdint.h linux/fuse.h} -type uint32_t -flags {
		FUSE_ATTR_SUBMOUNT
	}]
	#>>>
	# flagmap_fopen <<<
	set flagmap_fopen	[gen_flag_map -name fopen -headers {stdint.h linux/fuse.h} -type uint32_t -flags {
		FOPEN_DIRECT_IO
		FOPEN_KEEP_CACHE
		FOPEN_NONSEEKABLE
		FOPEN_CACHE_DIR
		FOPEN_STREAM
	}]
	#>>>
	# flagmap_open <<<
	set debugdir	/tmp/flagmap_open
	file delete -force $debugdir; file mkdir $debugdir
	set flagmap_open	[gen_flag_map -debug $debugdir -name open -headers {fcntl.h sys/stat.h} -flags {
		O_APPEND
		O_ASYNC
		O_CLOEXEC
		O_CREAT
		O_DIRECTORY
		O_DSYNC
		O_EXCL
		O_NOCTTY
		O_NOFOLLOW
		O_NONBLOCK
		O_NDELAY
		O_SYNC
		O_TRUNC
	}]
	#>>>
	# flagmap_mode <<<
	set flagmap_mode	[gen_flag_map -name mode -headers sys/stat.h -flags {
		S_IFMT
		S_IFSOCK
		S_IFLNK
		S_IFREG
		S_IFBLK
		S_IFDIR
		S_IFCHR
		S_IFOFO
		S_ISUID
		S_ISGID
		S_ISVTX

		S_IRWXU
		S_IRUSR
		S_IWUSR
		S_IXUSR

		S_IRWXG
		S_IRGRP
		S_IWGRP
		S_IXGRP

		S_IRWXO
		S_IROTH
		S_IWOTH
		S_IXOTH
	}]
	#>>>
	# flagmap_fuse_open <<<
	set flagmap_fuse_open	[gen_flag_map -name fuse_open -headers {stdint.h linux/fuse.h} -type uint32_t -flags {
		FUSE_OPEN_KILL_SUIDGID
	}]
	#>>>
	# flagmap_fuse_read <<<
	set flagmap_fuse_read	[gen_flag_map -name fuse_read -headers {stdint.h linux/fuse.h} -type uint32_t -flags {
		FUSE_READ_LOCKOWNER
	}]
	#>>>
	# enummap_errno <<<
	file delete -force /tmp/enummap_errno; file mkdir /tmp/enummap_errno
	set enummap_errno	[gen_enum_map -name errno -headers errno.h -debug /tmp/enummap_errno -vals {
		EPERM
		ENOENT
		ESRCH
		EINTR
		EIO
		ENXIO
		E2BIG
		ENOEXEC
		EBADF
		ECHILD
		EAGAIN
		ENOMEM
		EACCES
		EFAULT
		EBUSY
		EEXIST
		EXDEV
		ENODEV
		ENOTDIR
		EISDIR
		ENFILE
		EMFILE
		ENOTTY
		EFBIG
		ENOSPC
		ESPIPE
		EROFS
		EMLINK
		EPIPE
		EDOM
		EDEADLK
		ENAMETOOLONG
		ENOLCK
		ENOSYS
		ENOTEMPTY
		EINVAL
		ERANGE
		EILSEQ
	}]
	#>>>
	# struct fuse_getattr_in converter <<<
	file delete -force /tmp/fuse_struct_getattr_in; file mkdir /tmp/fuse_struct_getattr_in
	set struct_fuse_getattr_in	[gen_struct_converter -debug /tmp/fuse_struct_getattr_in -name fuse_getattr_in -headers {stdint.h linux/fuse.h} -fields {
		{uint32_t flags getattr}	getattr_flags
		uint64_t					fh
	}]
	#>>>
	# struct fuse_open_in converter <<<
	set debugdir	/tmp/struct_fuse_open_in
	file delete -force $debugdir; file mkdir $debugdir
	set struct_fuse_open_in	[gen_struct_converter -debug $debugdir -name fuse_open_in -headers {stdint.h linux/fuse.h} -fields {
		{uint32_t flags open}	flags
		{uint32_t flags fopen}	open_flags
	}]
	#>>>
	# struct fuse_open_out converter <<<
	set struct_fuse_open_out	[gen_struct_converter -name fuse_open_out -headers {stdint.h linux/fuse.h} -fields {
		uint64_t				fh
		{uint32_t flags fopen}	open_flags
	}]
	#>>>
	# struct fuse_attr converter <<<
	set struct_fuse_attr	[gen_struct_converter -name fuse_attr -headers {stdint.h linux/fuse.h} -fields {
		uint64_t					ino
		uint64_t					size
		uint64_t					blocks
		uint64_t					atime
		uint64_t					mtime
		uint64_t					ctime
		uint32_t					atimensec
		uint32_t					mtimensec
		uint32_t					ctimensec
		uint32_t					mode
		uint32_t					nlink
		uint32_t					uid
		uint32_t					gid
		uint32_t					rdev
		uint32_t					blksize
		{uint32_t flags attr}		flags
	}]
	#>>>
	# struct fuse_attr_out converter <<<
	set struct_fuse_attr_out	[gen_struct_converter -name fuse_attr_out -headers {stdint.h linux/fuse.h} -fields {
		uint64_t					attr_valid
		uint32_t					attr_valid_nsec
		{struct fuse_attr}			attr
	}]
	#>>>
	# struct fuse_init_out converter <<<
	set struct_fuse_init_out	[gen_struct_converter -name fuse_init_out -headers {stdint.h linux/fuse.h} -fields {
		uint32_t					major
		uint32_t					minor
		uint32_t					max_readahead
		{uint32_t flags initflags}	flags
		uint16_t					max_background
		uint16_t					congestion_threshold
		uint32_t					max_write
		uint32_t					time_gran
		uint16_t					max_pages
		uint16_t					map_alignment
	}]
	#>>>
	# struct fuse_read_in converter <<<
	file delete -force /tmp/fuse_read_in; file mkdir /tmp/fuse_read_in
	set struct_fuse_read_in	[gen_struct_converter -debug /tmp/fuse_read_in -name fuse_read_in -headers stdint.h -fields {
		uint64_t					fh
		uint64_t					offset
		uint32_t					size
		{uint32_t flags fuse_read}	read_flags
		uint64_t					lock_owner
		uint32_t					flags
	}]
	#>>>

	package require jitclib::obstackpool

	file delete -force /tmp/fusecmds; file mkdir /tmp/fusecmds
	interp alias {} fusecmds {} ::jitc::capply [list \
		define	_GNU_SOURCE \
		define	{DEBUG 1} \
		debug	/tmp/fusecmds \
		options	{-Wall -Werror -g0} \
		use		$fuse_io \
		use		$flagmap_initflags \
		use		$enummap_errno \
		use		$struct_fuse_getattr_in \
		use		$struct_fuse_open_in \
		use		$struct_fuse_read_in \
		use		$jitclib::obstackpool \
		use		[gen_fuse_writer -name init_out	-replystruct fuse_init_out] \
		use		[gen_fuse_writer -name attr_out	-replystruct fuse_attr_out] \
		use		[gen_fuse_writer -name open_out	-replystruct fuse_open_out] \
		code \
	{//@begin=c@<<<
		#include <unistd.h>
		#include <linux/fuse.h>
		#include <errno.h>
		#include <stdio.h>
		#include <string.h>
		#include <sys/stat.h>
		#include <sys/types.h>
		#include <fcntl.h>

		enum lit_objs {
			LIT_OPCODE,
			LIT_UNIQUE,
			LIT_NODEID,
			LIT_UID,
			LIT_GID,
			LIT_PID,
			LIT_TAIL,
			LIT_CUSE_INIT,
			LIT_MAJOR,
			LIT_MINOR,
			LIT_MAX_READAHEAD,
			LIT_FLAGS,
			LIT_IN,
			LIT_BLOCKED,
			LIT_EOF,
			LIT_TRUE,
			LIT_FALSE,
			_LIT_SIZE
		};
		//@end=c@@begin=c@
		const char*	lit_strs[] = {
			"opcode",
			"unique",
			"nodeid",
			"uid",
			"gid",
			"pid",
			"tail",
			"CUSE_INIT",
			"major",
			"minor",
			"max_readahead",
			"flags",
			"in",
			"_state blocked",
			"_state eof",
			"1",
			"0",
			NULL
		};

		//@end=c@@begin=c@
		#define fuse_opcode_max (FUSE_SYNCFS+1)
		Tcl_Obj*		lit[_LIT_SIZE] = {0};
		Tcl_Obj*		opcodes[fuse_opcode_max] = {0};
		Tcl_Obj*		g_cuse_init = NULL;
		//#define fuse_default_readbuf_size	FUSE_MIN_READ_BUFFER
		#define fuse_default_readbuf_size	5*1048576
		size_t			readbufsize = fuse_default_readbuf_size;
		static uint8_t	static_readbuf[fuse_default_readbuf_size] = {0};
		static void*	readbuf = static_readbuf;

		typedef int (opcode_decoder)(Tcl_Interp* interp, void* payload, Tcl_Obj** in);
		opcode_decoder*	decode[fuse_opcode_max] = {0};

		static int decode_fuse_init(Tcl_Interp* interp, struct fuse_init_in* p, Tcl_Obj** in) //<<<
		{
			int						code = TCL_OK;
			Tcl_Obj*				kernflags = NULL;
			Tcl_Obj*				msg = NULL;

			replace_tclobj(&msg, Tcl_NewDictObj());

			TEST_OK_LABEL(done, code, Tcl_DictObjPut(interp, msg, lit[LIT_MAJOR], Tcl_NewWideIntObj(p->major)));
			TEST_OK_LABEL(done, code, Tcl_DictObjPut(interp, msg, lit[LIT_MINOR], Tcl_NewWideIntObj(p->minor)));
			TEST_OK_LABEL(done, code, Tcl_DictObjPut(interp, msg, lit[LIT_MAX_READAHEAD], Tcl_NewWideIntObj(p->max_readahead)));
			TEST_OK_LABEL(done, code, get_list_from_initflags(interp, p->flags, &kernflags));
			TEST_OK_LABEL(done, code, Tcl_DictObjPut(interp, msg, lit[LIT_FLAGS], kernflags));

			replace_tclobj(in, msg);

		done:
			replace_tclobj(&msg, NULL);
			replace_tclobj(&kernflags, NULL);
			return code;
		}

		//>>>

		//@end=c@@begin=c@
		INIT { //<<<
			#define MAP_OPCODE(name) replace_tclobj(&opcodes[name], Tcl_NewStringObj(#name, -1));
			MAP_OPCODE(FUSE_LOOKUP);
			MAP_OPCODE(FUSE_FORGET);
			MAP_OPCODE(FUSE_GETATTR);
			MAP_OPCODE(FUSE_SETATTR);
			MAP_OPCODE(FUSE_READLINK);
			MAP_OPCODE(FUSE_SYMLINK);
			MAP_OPCODE(FUSE_MKNOD);
			MAP_OPCODE(FUSE_MKDIR);
			MAP_OPCODE(FUSE_UNLINK);
			MAP_OPCODE(FUSE_RMDIR);
			MAP_OPCODE(FUSE_RENAME);
			MAP_OPCODE(FUSE_LINK);
			MAP_OPCODE(FUSE_OPEN);
			MAP_OPCODE(FUSE_READ);
			MAP_OPCODE(FUSE_WRITE);
			MAP_OPCODE(FUSE_STATFS);
			MAP_OPCODE(FUSE_RELEASE);
			MAP_OPCODE(FUSE_FSYNC);
			MAP_OPCODE(FUSE_SETXATTR);
			MAP_OPCODE(FUSE_GETXATTR);
			MAP_OPCODE(FUSE_LISTXATTR);
			MAP_OPCODE(FUSE_REMOVEXATTR);
			MAP_OPCODE(FUSE_FLUSH);
			MAP_OPCODE(FUSE_INIT);
			MAP_OPCODE(FUSE_OPENDIR);
			MAP_OPCODE(FUSE_READDIR);
			MAP_OPCODE(FUSE_RELEASEDIR);
			MAP_OPCODE(FUSE_FSYNCDIR);
			MAP_OPCODE(FUSE_GETLK);
			MAP_OPCODE(FUSE_SETLK);
			MAP_OPCODE(FUSE_SETLKW);
			MAP_OPCODE(FUSE_ACCESS);
			MAP_OPCODE(FUSE_CREATE);
			MAP_OPCODE(FUSE_INTERRUPT);
			MAP_OPCODE(FUSE_BMAP);
			MAP_OPCODE(FUSE_DESTROY);
			MAP_OPCODE(FUSE_IOCTL);
			MAP_OPCODE(FUSE_POLL);
			MAP_OPCODE(FUSE_NOTIFY_REPLY);
			MAP_OPCODE(FUSE_BATCH_FORGET);
			MAP_OPCODE(FUSE_FALLOCATE);
			MAP_OPCODE(FUSE_READDIRPLUS);
			MAP_OPCODE(FUSE_RENAME2);
			MAP_OPCODE(FUSE_LSEEK);
			MAP_OPCODE(FUSE_COPY_FILE_RANGE);
			MAP_OPCODE(FUSE_SETUPMAPPING);
			MAP_OPCODE(FUSE_REMOVEMAPPING);
			MAP_OPCODE(FUSE_SYNCFS);
			#undef MAP_OPCODE

			for (int i=0; lit_strs[i]; i++)
				replace_tclobj(&lit[i], Tcl_NewStringObj(lit_strs[i], -1));

			decode[FUSE_INIT]		= (opcode_decoder*)decode_fuse_init;
			decode[FUSE_GETATTR]	= (opcode_decoder*)struct_fuse_getattr_in_to_dict;
			decode[FUSE_OPENDIR]	= (opcode_decoder*)struct_fuse_open_in_to_dict;
			decode[FUSE_READDIR]	= (opcode_decoder*)struct_fuse_read_in_to_dict;

			return TCL_OK;
		}

		//@end=c@@begin=c@ >>>
		RELEASE { //<<<
			for (int i=0; i<fuse_opcode_max; i++) replace_tclobj(&opcodes[i], NULL);
			for (int i=0; lit_strs[i]; i++) replace_tclobj(&lit[i], NULL);
			if (readbuf != static_readbuf) {
				ckfree(readbuf);
				readbuf = static_readbuf;
				readbufsize = fuse_default_readbuf_size;
			}
		}

		//@end=c@@begin=c@ >>>
		static int lookup_opcode(Tcl_Interp* interp, uint32_t opcode, Tcl_Obj** opcodeObj) //<<<
		{
			int			code = TCL_OK;

			if (opcode < fuse_opcode_max) {
				replace_tclobj(opcodeObj, opcodes[opcode]);
			} else if (opcode == CUSE_INIT) {
				replace_tclobj(opcodeObj, lit[LIT_CUSE_INIT]);
			} else {
				replace_tclobj(opcodeObj, Tcl_NewWideIntObj(opcode));
			}

		done:
			return code;
		}

		//@end=c@@begin=c@ >>>
		OBJCMD(read_fuse_req) { //<<<
			int						code = TCL_OK;
			int						fd;
			Tcl_Obj*				msg = NULL;
			Tcl_Obj*				opcodeObj = NULL;
			ssize_t					got_header;
			struct fuse_in_header*	req_header = NULL;

			CHECK_ARGS(1, "chan");

			TEST_OK_LABEL(done, code, Tcl_GetIntFromObj(interp, objv[1], &fd));
			fprintf(stderr, "Preparing to read from fuse fd: %d\n", fd);

			do {
				int err;
				got_header = read(fd, readbuf, readbufsize);
				err = errno;
				fprintf(stderr, "after read, got_header: %ld, errno: %d, sizeof *req_header: %ld\n", got_header, err, sizeof *req_header);

				if (got_header < (ssize_t)(sizeof *req_header)) {
					fprintf(stderr, "got_header: %ld < sizeof *req_header: %ld\n", got_header, sizeof *req_header);
					if (got_header == -1) {
						if (errno == EINTR) continue;
						if (errno == EAGAIN) {
							// Signal idle state
							Tcl_SetObjResult(interp, lit[LIT_BLOCKED]);
							goto done;
						}
						fprintf(stderr, "got_header == -1, errno: %d\n", errno);
						THROW_POSIX_LABEL(done, code, "Error calling read on fuse fd");
					} else if (got_header == 0) {
						// EOF
						Tcl_SetObjResult(interp, lit[LIT_EOF]);
						goto done;
					}
					//@end=c@@begin=c@
					THROW_PRINTF_LABEL(done, code, "Asked for %d bytes, but got %d\n", sizeof *req_header, got_header);
				} else {
					fprintf(stderr, "got_header: %ld >= sizeof *req_header: %ld\n", got_header, sizeof *req_header);
				}
			} while(0);
			//@end=c@@begin=c@
			if (got_header == -1) THROW_ERROR_LABEL(done, code, "Read header error, shouldn't happen");

			req_header = readbuf;
			if (got_header < req_header->len) {
				ssize_t			remain = req_header->len - got_header;

				if (remain > readbufsize) {
					const size_t newsize = req_header->len > FUSE_MIN_READ_BUFFER ? req_header->len : FUSE_MIN_READ_BUFFER;
					if (readbuf == static_readbuf) {
						uint8_t* newreadbuf = ckalloc(newsize);
						memcpy(newreadbuf, readbuf, got_header);
						readbuf = newreadbuf;
					} else {
						readbuf = ckrealloc(readbuf, newsize);
					}
					readbufsize = newsize;
					req_header = readbuf;
				}
			}

			if (got_header > req_header->len)
				fprintf(stderr, "Read more than expected (%ld): %ld\n", req_header->len, got_header);


			ssize_t	remain = req_header->len - got_header;

			if (remain > 0) {
				do {
					const ssize_t got_tail = read(fd, readbuf+got_header, readbufsize-got_header);
					fprintf(stderr, "got_tail: %ld, asked for: %ld, got_header: %ld, sizeof req_header: %ld\n", got_tail, remain, got_header, sizeof *req_header);

					if (got_tail <= remain) {
						if (got_tail == -1) {
							if (errno = EINTR) continue;
							THROW_POSIX_LABEL(done, code, "Error calling read on fuse fd");
						} else if (got_tail == 0) {
							// EOF
							goto done;
						}
						THROW_PRINTF_LABEL(done, code, "Asked for %d bytes, but got %d\n", readbufsize-got_header, got_tail);
					}
				} while(0);
			}

			replace_tclobj(&msg, Tcl_NewDictObj());

			TEST_OK_LABEL(done, code, lookup_opcode(interp, req_header->opcode, &opcodeObj));
			TEST_OK_LABEL(done, code, Tcl_DictObjPut(interp, msg, lit[LIT_OPCODE], opcodeObj));
			TEST_OK_LABEL(done, code, Tcl_DictObjPut(interp, msg, lit[LIT_UNIQUE], Tcl_NewWideIntObj(req_header->unique)));
			TEST_OK_LABEL(done, code, Tcl_DictObjPut(interp, msg, lit[LIT_NODEID], Tcl_NewWideIntObj(req_header->nodeid)));
			TEST_OK_LABEL(done, code, Tcl_DictObjPut(interp, msg, lit[LIT_UID], Tcl_NewWideIntObj(req_header->uid)));
			TEST_OK_LABEL(done, code, Tcl_DictObjPut(interp, msg, lit[LIT_GID], Tcl_NewWideIntObj(req_header->gid)));
			TEST_OK_LABEL(done, code, Tcl_DictObjPut(interp, msg, lit[LIT_PID], Tcl_NewWideIntObj(req_header->pid)));
			TEST_OK_LABEL(done, code, Tcl_DictObjPut(interp, msg, lit[LIT_TAIL], Tcl_NewByteArrayObj(readbuf+sizeof *req_header, req_header->len-sizeof(*req_header))));

			if (req_header->opcode < fuse_opcode_max && decode[req_header->opcode]) {
				Tcl_Obj*	in = NULL;
				TEST_OK_LABEL(donein, code, (decode[req_header->opcode])(interp, readbuf+sizeof *req_header, &in));
				TEST_OK_LABEL(donein, code, Tcl_DictObjPut(interp, msg, lit[LIT_IN], in));
			donein:
				replace_tclobj(&in, NULL);
				if (code != TCL_OK) goto done;
			}

			Tcl_SetObjResult(interp, msg);

		done:
			replace_tclobj(&msg, NULL);
			replace_tclobj(&opcodeObj, NULL);

			return code;
		}

		//>>>
		OBJCMD(write_error) { //<<<
			int				code = TCL_OK;
			Tcl_WideInt		unique;
			int				err;
			int				fd;

			CHECK_ARGS(3, "fd unique errno");

			TEST_OK_LABEL(done, code, Tcl_GetIntFromObj(interp, objv[1], &fd));
			TEST_OK_LABEL(done, code, Tcl_GetWideIntFromObj(interp, objv[2], &unique));
			TEST_OK_LABEL(done, code, get_errno_from_obj(interp, objv[3], &err));

			struct fuse_out_header	hdr = {
				.len		= sizeof hdr,
				.error		= err,
				.unique		= unique
			};

			TEST_OK_LABEL(done, code, fuse_write(interp, fd, &hdr, sizeof hdr));

		done:
			return code;
		}

		//>>>
		OBJCMD(is_dir) { //<<<
			int			code = TCL_OK;
			CHECK_ARGS(1, "mode");
			Tcl_WideInt	mode;
			TEST_OK_LABEL(done, code, Tcl_GetWideIntFromObj(interp, objv[1], &mode));
			Tcl_SetObjResult(interp, mode & S_IFDIR ? lit[LIT_TRUE] : lit[LIT_FALSE]);
		done:
			return code;
		}

		//>>>
		OBJCMD(write_fuse_readdir_out) { //<<<
			int						code = TCL_OK;
			struct obstack*			ob = NULL;
			struct fuse_out_header*	hdr = NULL;
			Tcl_Obj**				dv = NULL;
			int						dc;
			Tcl_WideInt				unique, size, off;
			int						i;
			int						fd;
			char					zeros[32] = {0};

			CHECK_ARGS(5, "fd unique off size dirents");

			TEST_OK_LABEL(done, code, Tcl_GetIntFromObj(interp, objv[1], &fd));
			TEST_OK_LABEL(done, code, Tcl_GetWideIntFromObj(interp, objv[2], &unique));
			TEST_OK_LABEL(done, code, Tcl_GetWideIntFromObj(interp, objv[3], &off));
			TEST_OK_LABEL(done, code, Tcl_GetWideIntFromObj(interp, objv[4], &size));
			TEST_OK_LABEL(done, code, Tcl_ListObjGetElements(interp, objv[5], &dc, &dv));

			ob = obstack_pool_get(OBSTACK_POOL_MEDIUM);

			obstack_blank(ob, sizeof(*hdr));

			int	last = obstack_object_size(ob);
			for (i=off; i<dc; i++) {
				int			namelen;
				Tcl_WideInt	inode;
				Tcl_WideInt	type;
				Tcl_Obj**	dentv = NULL;
				int			dentc;

				TEST_OK_LABEL(done, code, Tcl_ListObjGetElements(interp, dv[i], &dentc, &dentv));
				if (dentc != 3) THROW_ERROR_LABEL(done, code, "dirent must be a list of elements: name, inode, type");

				const char*			name = Tcl_GetStringFromObj(dentv[0], &namelen);
				TEST_OK_LABEL(done, code, Tcl_GetWideIntFromObj(interp, dentv[1], &inode));
				TEST_OK_LABEL(done, code, Tcl_GetWideIntFromObj(interp, dentv[2], &type));

				const int			sizenow = obstack_object_size(ob);
				const int			dentlen = FUSE_NAME_OFFSET + namelen;
				const int			padding = FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET + namelen) - dentlen;
				const int			dentsize = dentlen + padding;

				if (sizenow + dentsize > size) break;

				struct fuse_dirent d = {
					.ino		= inode,
					.off		= i+1,
					.namelen	= namelen,
					.type		= (type & S_IFMT) >> 12
				};

				obstack_grow(ob, &d, sizeof(d));
				obstack_grow(ob, name, namelen);
				obstack_grow(ob, zeros, padding);

				fprintf(stderr, "obstack dirent size: %d, namelen: %d, padding: %d\n",
					obstack_object_size(ob) - last,
					namelen,
					padding);
				last = obstack_object_size(ob);
			}

			const int	len = obstack_object_size(ob);
			hdr = obstack_finish(ob);
			*hdr = (struct fuse_out_header){
				.len	= len,
				.unique	= unique
			};

			TEST_OK_LABEL(done, code, fuse_write(interp, fd, hdr, hdr->len));

			fprintf(stderr, "Wrote %ld bytes out, %d entries, is all? %d, unique: %ld\n", hdr->len, i-off, i==dc, hdr->unique);

			Tcl_SetObjResult(interp, i == dc ? lit[LIT_TRUE] : lit[LIT_FALSE]);

		done:
			if (ob) {
				obstack_pool_release(ob);
				ob = NULL;
			}
			return code;
		}

		//>>>
		OBJCMD(open_fuse) { //<<<
			int			code = TCL_OK;
			int			fd;

			CHECK_ARGS(0, "");

			fd = open("/dev/fuse", O_CLOEXEC | O_RDWR | O_NONBLOCK);
			if (-1 == fd) THROW_POSIX_LABEL(done, code, "Error opening /dev/fuse");

			Tcl_SetObjResult(interp, Tcl_NewIntObj(fd));

		done:
			return code;
		}

		//>>>
		OBJCMD(close_fuse) { //<<<
			int			code = TCL_OK;
			int			fd;

			CHECK_ARGS(1, "fd");

			TEST_OK_LABEL(done, code, Tcl_GetIntFromObj(interp, objv[1], &fd));
			const int rc = close(fd);
			if (-1 == rc) THROW_POSIX_LABEL(done, code, "Error closing /dev/fuse");

		done:
			return code;
		}

		//>>>
	//@end=c@>>>}]

	proc fstime usec {list [expr {$usec/1000000}] [expr {($usec%1000000) * 1000}]}

	set inode_seq	0
	set fh_seq		0
	set nodes		{}
	set handles		{}

	proc fopen {inode mode} { #<<<
		global nodes handles fh_seq
		set fh	[incr fh_seq]
		if {![dict exists $nodes $inode]} {throw fuse_posix ENOENT}
		# TODO: check mode
		dict set handles $fh [dict create \
			inode	$inode \
			offset	0 \
		]
		set fh
	}

	#>>>
	proc fclose fh { #<<<
		global handles
		if {![dict exists $handles $fh]} {throw fuse_posix EBADF}
		dict unset $handles $fh
	}

	#>>>

	lassign [fstime [clock microseconds]] now_s now_ns
	dict set nodes 1 [list \
		ino			1 \
		parent		1 \
		size		4096 \
		blocks		8 \
		atime		$now_s \
		mtime		$now_s \
		ctime		$now_s \
		atimensec	$now_ns \
		mtimensec	$now_ns \
		ctimensec	$now_ns \
		mode		0o40755 \
		nlink		2 \
		uid			1000 \
		gid			1000 \
		blksize		4096 \
		flags {
		} \
		children	{} \
	]	;# Root

	proc readable fd {
		global nodes handles

		puts stderr "fuse fd readable"
		while 1 {
			try {
				puts "read fuse msg: [timerate {
				set msg	[fusecmds read_fuse_req $fd]
				} 1 1]"

				if {[dict exists $msg _state]} {
					switch -exact -- [dict get $msg _state] {
						eof {
							puts stderr "Got EOF on fuse fd"
							cleanup
							return
						}
						blocked {
							puts stderr "Got EAGAIN on fuse fd"
							return
						}
						default {
							error "Unhandled _state signalled by read_fuse_req: ([dict get $msg _state])"
						}
					}
				}

				set seen	{}
				puts "Received fuse msg:\n\t[join [lmap v {opcode unique nodeid uid gid pid} {
					dict set seen $v 1
					format {%8s: (%s)} $v [dict get $msg $v]
				}] \n\t]"
				puts stderr "payload: [regexp -all -inline .. [binary encode hex [dict get $msg tail]]]"
				dict set seen tail 1
				dict for {k v} $msg {
					if {[dict exists $seen $k]} continue
					puts [format {%12s: (%s)} $k [dict get $msg $k]]
				}

				switch -exact -- [dict get $msg opcode] {
					FUSE_INIT {
						if {[incr ::fuse_init_count] > 2} {error "FUSE_INIT loop, bailing"}

						if {[dict get $msg in major] > 7} {
							# TODO: reply with just major 7
							error "Major protocol version mismatch and negotiation not supported"
						} elseif {[dict get $msg in major] < 7} {
							error "Major protocol version from kernel is too old"
						} elseif {[dict get $msg in minor] < 34} {
							error "Minor version too old"
						}
						fusecmds write_fuse_init_out $fd [dict get $msg unique] [dict create \
							major					7 \
							minor					34 \
							max_readahead			[expr {4*1048576}] \
							flags					{
								FUSE_ATOMIC_O_TRUNC
								FUSE_BIG_WRITES
								FUSE_ABORT_ERROR
							} \
							max_background			8 \
							congestion_threshold	4 \
							max_read				0 \
							max_write				[expr {4*1048576}] \
							time_gran				1000 \
						]
					}

					FUSE_GETATTR {
						set unique	[dict get $msg unique]
						if {"FUSE_GETATTR_FH" in [dict get $msg in getattr_flags]} {
							if {![dict exists $handles [dict get $msg in fh]]} {
								throw fuse_posix EBADF
							}
							set nodeid	[dict get $handles [dict get $msg fh] inode]
						} else {
							set nodeid	[dict get $msg nodeid]
						}

						if {[dict exists $nodes $nodeid]} {
							set attrs	[dict get $nodes $nodeid]
							if {[fusecmds is_dir [dict get $attrs mode]]} {
								fusecmds write_fuse_attr_out $fd $unique [dict create \
									attr_valid		2 \
									attr_valid_nsec	500 \
									attr			$attrs \
								]
							} else {
								throw fuse_posix ENOTDIR
							}
						} else {
							throw fuse_posix ENOENT
						}
					}

					FUSE_OPENDIR {
						puts stderr "handling FUSE_OPENDIR"
						set fh	[fopen [dict get $msg nodeid] 0]
						puts stderr "assigned fh: ($fh)"
						fusecmds write_fuse_open_out $fd [dict get $msg unique] [dict create \
							fh			$fh \
							open_flags	{} \
						]
					}

					FUSE_READDIR {
						puts stderr "Handling FUSE_READDIR"
						set fh		[dict get $msg in fh]
						if {![dict exists $handles $fh]} {throw fuse_posix EBADF}
						set inode	[dict get $handles $fh inode]
						if {![dict exists $nodes $inode]} {throw fuse_posix ENOENT}
						set off		[dict get $msg in offset]
						set size	[dict get $msg in size]
						set dir		[dict get $nodes $inode]
						if {![fusecmds is_dir [dict get $dir mode]]} {throw fuse_posix ENOTDIR}
						set parent	[dict get $dir parent]
						if {$off == 0 || ![dict exists $handles $fh dirents]} {
							dict set handles $fh dirents [list \
								[list .  $inode  [dict get $dir mode]] \
								[list .. $parent [dict get $nodes $parent mode]] \
								{*}[lmap {name ino} [dict get $dir children] {
									list $name $ino [dict get $nodes $ino mode]
								}] \
							]
						}
						if {[fusecmds write_fuse_readdir_out $fd [dict get $msg unique] $off $size [dict get $handles $fh dirents]]} {
							puts stderr "Wrote readdir response, all entries consumed, releasing dirents"
							# Used all entries
							dict unset handles $fh dirents
						} else {
							puts stderr "Write readdir response, not all entries consumed, hanging on to dirents"
						}
					}

					default {
						error "opcode ([dict get $msg opcode]) not handled"
					}
				}

				#set i [read $fd 4]
				#binary scan $i n len
				#puts stderr "Read len: $len"
				#set rest	[read $fd [expr {$len-4}]]
				#binary scan $rest nmmnnnna* opcode unique nodeid uid gid pid padding tail
				#foreach v {opcode unique nodeid uid gid pid} {
				#	puts stderr "$v: $v"
				#}
				#puts stderr "payload: [regexp -all -inline .. [binary encode hex $tail]]"
			} trap fuse_posix {errno options} {
				puts stderr "Throwing posix exception: $errno"
				fusecmds write_error $fd [dict get $msg unique] $errno
			} on error {errmsg options} {
				puts "fuse fd readable error [dict get $options -errorcode]: [dict get $options -errorinfo]"
				if {[info exists msg] && [dict exists $msg unique]} {
					puts stderr "Writing error reply"
					fusecmds write_error $fd [dict get $msg unique] EINVAL
				}
				cleanup
				return -options $options $errmsg
			}
		}
		puts stderr "Leaving fuse fd readable cb"
	}

	set fd	[fusecmds open_fuse]

	proc poll {} {
		global fd
		puts stderr "poll"
		try {
			readable $fd
		} on error {errmsg options} {
			puts stderr "Error from readable: [dict get $options -errorinfo]"
		} on ok {} {
			after 5000 poll
		}
	}

	#after 5000 poll

	package require jitclib::tempdir
	set tempdir	[jitc::capply $::jitclib::tempdir tempdir fuseraw_test_]
	#catch {exec umount -f /tmp/fuseraw_test_manual}
	#file delete -force /tmp/fuseraw_test_manual
	#file mkdir /tmp/fuseraw_test_manual
	#set tempdir /tmp/fuseraw_test_manual

	file delete -force /tmp/dbg
	file mkdir /tmp/dbg
	set mount {debug /tmp/dbg options {-Wall -Werror -g} code {//@begin=c@<<<
		#include <sys/mount.h>
		#include <stdio.h>
		#include <unistd.h>
		#include <fcntl.h>

		OBJCMD(do_mount) {
			int			code = TCL_OK;
			Tcl_Obj*	fsargs = NULL;
			int			fd;

			CHECK_ARGS(2, "fd mountpoint");

			TEST_OK_LABEL(done, code, Tcl_GetIntFromObj(interp, objv[1], &fd));
			int mountpoint_len;
			const char* mountpoint = Tcl_GetStringFromObj(objv[2], &mountpoint_len);

			fcntl(fd, F_SETFD, 0);

			replace_tclobj(&fsargs, Tcl_ObjPrintf("fd=%d,rootmode=%o,user_id=1000,group_id=1000", fd, S_IFDIR));

			fprintf(stderr, "Calling mount(), mountpoint: (%s), fsargs: (%s)\n", mountpoint, Tcl_GetString(fsargs));
			//const int mount_rc = mount("fuseraw", mountpoint, "fuse", MS_NOEXEC | MS_NOSUID, Tcl_GetString(fsargs));
			const int mount_rc = mount("fuse", mountpoint, "fuse", 0, Tcl_GetString(fsargs));
			if (mount_rc == -1)
				THROW_POSIX_LABEL(done, code, "Error calling mount");

		done:
			replace_tclobj(&fsargs, NULL);
			return code;
		}

		//@end=c@
	}}

	#>>>
	puts stderr "compiling mount"
	puts stderr "mount symbols: [jitc::symbols $mount]"

	if 1 {
		puts stderr "Calling mount ([info exists mount]) on $tempdir: [exec ls -ald $tempdir]"
		jitc::capply $mount do_mount $fd $tempdir
	} else {
		try {
			exec mount.fuse3 fuseraw#foo -o fd=$fd $tempdir
		} on error {errmsg options} {
			puts stderr "mount error: $options"
		}
	}
	thread::send -async $epoll_tid [list poll $fd [list thread::send [thread::id] [list readable $fd]]]

	set tempdir
}]

puts stderr "Calling glob $tempdir/*"
#puts stderr "Glob: ([glob -types hidden $tempdir/*])"
puts stderr "ls: [exec ls -a $tempdir]"
puts stderr "Mainthread waiting"
after 3000
puts stderr "Mainthread releasing fs_tid"

thread::release $fs_tid

puts stderr "Waiting for fs thread"
thread::join $fs_tid

#puts stderr "Unmounting ($mountpoint)"
#exec umount $mountpoint
#puts stderr "Unmounted"

# vim: ft=tcl foldmethod=marker foldmarker=<<<,>>> ts=4 shiftwidth=4
# TODO: syn sync minlines=1000
