if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import ::tcltest::*
}

::tcltest::loadTestedCommands
package require jitc

test capply-1.1 {hello, world} -body { #<<<
	jitc::capply {
		include_path local/lib/tcc/include
		include_path /home/cyan/local8.7_valgrind/include
		library_path local/lib/tcc
		library_path /home/cyan/local8.7_valgrind/lib

		code { //@begin=c@
			#include <tcl.h>

			int hello(ClientData cdata, Tcl_Interp* interp, int objc, Tcl_Obj *const objv[])
			{
				int			code = TCL_OK;

				if (objc != 3) {
					Tcl_WrongNumArgs(interp, 1, objv, "a b");
					code = TCL_ERROR;
					goto finally;
				}

				Tcl_SetObjResult(interp, Tcl_ObjPrintf("hello, %s and %s",
					Tcl_GetString(objv[1]),
					Tcl_GetString(objv[2])));

			finally:
				return code;
			}
			//@end=c@
		}
	} hello foo bar
} -result {hello, foo and bar}
#>>>
test capply-2.1 {missing symbol} -body { #<<<
	jitc::capply {
		include_path local/lib/tcc/include
		include_path /home/cyan/local8.7_valgrind/include
		library_path local/lib/tcc
		library_path /home/cyan/local8.7_valgrind/lib

		code { //@begin=c@
			#include <tcl.h>

			int hello(ClientData cdata, Tcl_Interp* interp, int objc, Tcl_Obj *const objv[])
			{
				int			code = TCL_OK;

				if (objc != 3) {
					Tcl_WrongNumArgs(interp, 1, objv, "a b");
					code = TCL_ERROR;
					goto finally;
				}

				Tcl_SetObjResult(interp, Tcl_ObjPrintf("hello, %s and %s",
					Tcl_GetString(objv[1]),
					Tcl_GetString(objv[2])));

			finally:
				return code;
			}
			//@end=c@
		}
	} hellox foo bar
} -returnCodes error -errorCode {JITC SYMBOL hellox} -result {Symbol not found: "hellox"}
#>>>
test capply-3.1 {exception} -body { #<<<
	jitc::capply {
		include_path local/lib/tcc/include
		include_path /home/cyan/local8.7_valgrind/include
		library_path local/lib/tcc
		library_path /home/cyan/local8.7_valgrind/lib

		code { //@begin=c@
			#include <tcl.h>

			int exception(ClientData cdata, Tcl_Interp* interp, int objc, Tcl_Obj *const objv[])
			{
				int			code = TCL_OK;

				if (objc != 3) {
					Tcl_WrongNumArgs(interp, 1, objv, "a b");
					code = TCL_ERROR;
					goto finally;
				}

				Tcl_SetErrorCode(interp, "FOO", "BAR", "BAZ", NULL);
				Tcl_SetObjResult(interp, Tcl_NewStringObj("Some error message", -1));
				code = TCL_ERROR;

			finally:
				return code;
			}
			//@end=c@
		}
	} exception foo bar
} -returnCodes error -errorCode {FOO BAR BAZ} -result {Some error message}
#>>>
test capply-3.2 {exception: args} -setup { #<<<
	set cdef	{
		include_path local/lib/tcc/include
		include_path /home/cyan/local8.7_valgrind/include
		library_path local/lib/tcc
		library_path /home/cyan/local8.7_valgrind/lib

		code { //@begin=c@
			#include <tcl.h>

			int exception(ClientData cdata, Tcl_Interp* interp, int objc, Tcl_Obj *const objv[])
			{
				int			code = TCL_OK;

				if (objc != 3) {
					Tcl_WrongNumArgs(interp, 1, objv, "a b");
					code = TCL_ERROR;
					goto finally;
				}

				code = TCL_ERROR;

			finally:
				return code;
			}
			//@end=c@
		}
	}
} -body {
	jitc::capply $cdef exception foo
} -cleanup {
	unset -nocomplain cdef
} -returnCodes error -errorCode {TCL WRONGARGS} -result {wrong # args: should be "exception a b"}
#>>>
test capply-4.1 {mode: standard} -setup { #<<<
	set cdef	{
		code { //@begin=c@
			int msg(ClientData cdata, Tcl_Interp* interp, int objc, Tcl_Obj *const objv[])
			{
				int			code = TCL_OK;
				Tcl_Obj*	msg = NULL;

				CHECK_ARGS(2, "a b");

				replace_tclobj(&msg, Tcl_ObjPrintf("hello, %s and %s", Tcl_GetString(objv[1]), Tcl_GetString(objv[2])));
				Tcl_SetObjResult(interp, msg);

			finally:
				replace_tclobj(&msg, NULL);

				return code;
			}
			//@end=c@
		}
	}
} -body {
	jitc::capply $cdef msg foo bar
} -cleanup {
	unset -nocomplain cdef
} -result {hello, foo and bar}
#>>>
test capply-4.2 {mode: raw} -setup { #<<<
	set cdef	{
		mode	raw
		code { //@begin=c@
			int msg(ClientData cdata, Tcl_Interp* interp, int objc, Tcl_Obj *const objv[])
			{
				int			code = TCL_OK;
				Tcl_Obj*	msg = NULL;

				CHECK_ARGS(2, "a b");

				replace_tclobj(&msg, Tcl_ObjPrintf("hello, %s and %s", Tcl_GetString(objv[1]), Tcl_GetString(objv[2])));
				Tcl_SetObjResult(interp, msg);

			finally:
				replace_tclobj(&msg, NULL);

				return code;
			}
			//@end=c@
		}
	}
} -body {
	jitc::capply $cdef msg foo bar
} -cleanup {
	unset -nocomplain cdef
} -returnCodes error -match glob -result "*<string>:2: error: ',' expected (got \"cdata\")*"
#>>>
test capply-5.1 {OBJCMD} -body { #<<<
	jitc::capply {
		code {
			OBJCMD(foo) {
				CHECK_ARGS(0, "");
				Tcl_SetObjResult(interp, Tcl_NewStringObj("bar", 3));
				return TCL_OK;
			}
		}
	} foo
} -result bar
#>>>
test capply-6.1 {dedup} -setup { #<<<
	set cdef	{
		include_path	/home/cyan/local8.7_valgrind/include
		library_path	/home/cyan/local8.7_valgrind/lib
		library_path	/home/cyan/local8.7_valgrind/lib/dedup0.9.0
		library			dedup0.9.0
		code {
			#include <dedup.h>

			struct dedup_pool*	g_dedup = NULL;

			INIT() {
				TEST_OK(Tcl_PkgRequireProc(interp, "dedup", 0, NULL, NULL));
				g_dedup = Dedup_NewPool(interp);
				return TCL_OK;
			}

			RELEASE() {
				Dedup_FreePool(g_dedup);
				g_dedup = NULL;
			}

			OBJCMD(foo) {
				CHECK_ARGS(0, "");
				Tcl_SetObjResult(interp, Dedup_NewStringObj(g_dedup, "bar", 3));
				return TCL_OK;
			}
		}
	}
} -body {
	jitc::capply $cdef foo
} -cleanup {
	unset -nocomplain cdef
} -result bar
#>>>
test capply-6.2 {dedup stubs} -setup { #<<<
	set cdef	{
		include_path	/home/cyan/local8.7_valgrind/include
		library_path	/home/cyan/local8.7_valgrind/lib
		library_path	/home/cyan/local8.7_valgrind/lib/dedup0.9.0
		define			{USE_TCL_STUBS 1}
		define			{USE_DEDUP_STUBS 1}
		code {
			#include <dedup.h>

			struct dedup_pool*	g_dedup = NULL;

			INIT() {
				#if USE_TCL_STUBS
				if (Tcl_InitStubs(interp, TCL_VERSION, 0) == NULL) return TCL_ERROR;
				#endif
				#if USE_DEDUP_STUBS
				if (Dedup_InitStubs(interp) == NULL) return TCL_ERROR;
				#endif

				g_dedup = Dedup_NewPool(interp);
				return TCL_OK;
			}

			RELEASE() {
				Dedup_FreePool(g_dedup);
				g_dedup = NULL;
			}

			OBJCMD(foo) {
				CHECK_ARGS(0, "");
				Tcl_SetObjResult(interp, Dedup_NewStringObj(g_dedup, "bar", 3));
				return TCL_OK;
			}
		}
		library			dedupstub0.9.0
		library			tclstub8.7
	}
} -body {
	jitc::capply $cdef foo
} -cleanup {
	unset -nocomplain cdef
} -result bar
#>>>
test capply-6.3 {dedup no stubs, tcl package requireq} -setup { #<<<
	package require dedup
	set cdef	{
		include_path	/home/cyan/local8.7_valgrind/include
		library_path	/home/cyan/local8.7_valgrind/lib/dedup0.9.0
		library			dedup0.9.0
		code {
			#include <dedup.h>

			struct dedup_pool*	g_dedup = NULL;

			INIT() {
				g_dedup = Dedup_NewPool(interp);
				return TCL_OK;
			}

			RELEASE() {
				Dedup_FreePool(g_dedup);
				g_dedup = NULL;
			}

			OBJCMD(foo) {
				CHECK_ARGS(0, "");
				Tcl_SetObjResult(interp, Dedup_NewStringObj(g_dedup, "bar", 3));
				return TCL_OK;
			}
		}
	}
} -body {
	jitc::capply $cdef foo
} -cleanup {
	unset -nocomplain cdef
} -result bar
#>>>

# cleanup
::tcltest::cleanupTests
return

# vim: ft=tcl foldmethod=marker foldmarker=<<<,>>> ts=4 shiftwidth=4
